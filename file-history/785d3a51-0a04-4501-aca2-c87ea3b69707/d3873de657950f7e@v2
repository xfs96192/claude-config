#!/usr/bin/env python3
"""
Generate a comprehensive web dashboard for the weekly report.
Reads data from the extracted JSON and generates a self-contained HTML file.
Matches the structure and formatting of the PDF weekly report.
"""
import json
import os
import math
import re

# ─── Configuration ───
JSON_PATH = '/tmp/weekly_report_data.json'
OUTPUT_HTML = '/Users/fanshengxia/Desktop/周报V2/输出结果/周报仪表板-20260205.html'
REPORT_DATE = '2026-02-05'
REPORT_TITLE = '多资产投资部理财产品运作周报'

# ─── Load Data ───
with open(JSON_PATH, 'r', encoding='utf-8') as f:
    raw_data = json.load(f)

output_sheets = raw_data['output_file']
vba_sheets = raw_data['vba_workbook']

# ─── Sheets that should use integer display with parentheses for negatives ───
SCALE_INT_SHEETS = {
    '2、产品规模',
    '1、分渠道余额',
    '投资经理维度产品规模和数量',
    '不同形态产品规模和数量',
    '13.不同周期产品规模',
    '14.狭义客户周期和最短持有期的产品规模跟踪',
    '10.未来全年产品到期情况',
    '10.未来全年产品到期情况-定开',
}

# ─── Sheets with percentage values already in percentage form (e.g., 1.87 = 1.87%) ───
PCT_RAW_SHEETS = {
    '15.市场指数收益',
}

# ─── Sheets with percentage values in decimal form (e.g., 0.0187 = 1.87%) ───
PCT_DECIMAL_SHEETS = {
    '系列产品业绩-费后加权',
    '系列产品业绩-费后平均',
    '系列产品业绩-费前加权',
    '系列产品业绩-费前平均',
    '5.2 最短持有期产品业绩表现1',
    '5.2 最短持有期产品业绩表现2',
}


# ─── Helper Functions ───

def is_numeric(val):
    if val is None:
        return False
    if isinstance(val, (int, float)):
        return not (isinstance(val, float) and (math.isnan(val) or math.isinf(val)))
    if isinstance(val, str):
        try:
            float(val)
            return True
        except:
            return False
    return False


def to_float(val):
    if val is None:
        return None
    if isinstance(val, (int, float)):
        if isinstance(val, float) and (math.isnan(val) or math.isinf(val)):
            return None
        return float(val)
    if isinstance(val, str):
        if val in ('nan', 'inf', '-inf', ''):
            return None
        try:
            return float(val)
        except:
            return None
    return None


def escape_html(s):
    if s is None:
        return ''
    s = str(s)
    return s.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;')


def detect_column_types(sheet_data, sheet_name=''):
    """Detect which columns contain percentages, basis points, or regular numbers."""
    data = sheet_data['data']
    headers = data[0] if data else []
    col_types = {}

    for ci in range(len(headers)):
        h = str(headers[ci] or '')
        h_lower = h.lower()

        # Force override for known sheet types
        if sheet_name in PCT_RAW_SHEETS:
            is_pct_header = '年化' in h or '收益率' in h or '波动率' in h or '占比' in h
            if is_pct_header:
                col_types[ci] = 'percent_raw'
                continue

        if sheet_name in PCT_DECIMAL_SHEETS:
            is_pct_header = '年化' in h or '收益率' in h or '波动率' in h or '占比' in h
            if is_pct_header:
                col_types[ci] = 'percent'
                continue

        if 'bp' in h_lower or '净值变化bp' in h:
            col_types[ci] = 'bps'
            continue

        is_pct_header = '年化' in h or '收益率' in h or '波动率' in h or '占比' in h or '比例' in h

        if is_pct_header:
            numeric_vals = []
            for ri in range(1, min(len(data), 20)):
                if ci < len(data[ri]):
                    v = to_float(data[ri][ci])
                    if v is not None and v != 0:
                        numeric_vals.append(abs(v))
            if numeric_vals:
                avg = sum(numeric_vals) / len(numeric_vals)
                if avg > 0.5:
                    col_types[ci] = 'percent_raw'
                else:
                    col_types[ci] = 'percent'
            else:
                col_types[ci] = 'percent'
        else:
            # Auto-detect percentage columns by value range
            numeric_vals = []
            for ri in range(1, min(len(data), 20)):
                if ci < len(data[ri]):
                    v = to_float(data[ri][ci])
                    if v is not None and v != 0:
                        numeric_vals.append(abs(v))
            if len(numeric_vals) >= 2:
                avg = sum(numeric_vals) / len(numeric_vals)
                max_v = max(numeric_vals)
                if 0 < avg < 0.5 and max_v < 1.5:
                    col_types[ci] = 'percent'

    return col_types


def format_cell_value(val, col_type=None, use_parens=False):
    """Format a cell value based on its type.
    use_parens: if True, show negatives as (N) instead of -N, and use integer display for scale values.
    """
    if val is None:
        return ''
    if isinstance(val, str):
        if val in ('nan', 'inf', '-inf'):
            return ''
        try:
            fval = float(val)
            val = fval
        except:
            return escape_html(val)

    if isinstance(val, bool):
        return str(val)
    if not isinstance(val, (int, float)):
        return escape_html(str(val))
    if math.isnan(val) or math.isinf(val):
        return ''

    if col_type == 'percent':
        pct = val * 100
        return f'{pct:.2f}%'
    elif col_type == 'percent_raw':
        return f'{val:.2f}%'
    elif col_type == 'bps':
        return f'{val:.2f}'

    # Scale integer mode: show rounded integers with parentheses for negatives
    if use_parens:
        # For very small values close to 0
        if abs(val) < 0.05:
            return '-'
        # Small decimals (< 1): show one decimal place
        if abs(val) < 1 and abs(val) >= 0.05:
            if val < 0:
                return f'({abs(val):.1f})'
            return f'{val:.1f}'
        # Integer display for values >= 1
        rounded = round(val)
        if rounded == 0:
            return '-'
        if rounded < 0:
            return f'({abs(rounded):,})'
        return f'{rounded:,}'

    # Default formatting
    if isinstance(val, int) or (isinstance(val, float) and val == int(val) and abs(val) < 10000):
        return str(int(val))
    elif abs(val) < 0.0001 and val != 0:
        return f'{val:.6f}'
    elif abs(val) < 0.01 and val != 0:
        return f'{val:.4f}'
    elif abs(val) < 100:
        return f'{val:.2f}'
    elif abs(val) < 100000:
        return f'{val:,.2f}'
    else:
        return f'{val:,.0f}'


def get_cell_class(val, col_type=None, header=''):
    """Get CSS class for conditional formatting."""
    classes = []
    if val is None:
        return ''

    fval = to_float(val)
    if fval is None:
        return ''

    h = str(header).lower()

    is_change = any(kw in h for kw in ['变化', '较上周', '较上月', '较上年', 'bp'])
    is_return = any(kw in h for kw in ['年化', '收益率'])

    if is_change:
        if fval > 0:
            classes.append('val-positive')
        elif fval < 0:
            classes.append('val-negative')

    if is_return and col_type == 'percent':
        if fval < 0:
            classes.append('val-negative')

    # Heatmap intensity for change columns
    if is_change and fval != 0:
        if col_type == 'percent':
            intensity = min(abs(fval) * 20, 1)
        elif col_type == 'percent_raw':
            intensity = min(abs(fval) / 5, 1)
        elif 'bp' in h:
            intensity = min(abs(fval) / 50, 1)
        else:
            intensity = min(abs(fval) / 20, 1)
        level = min(int(intensity * 5) + 1, 5)
        if fval > 0:
            classes.append(f'heat-pos-{level}')
        else:
            classes.append(f'heat-neg-{level}')

    return ' '.join(classes)


def parse_merged_cells(merged_list):
    """Parse merged cell ranges into a dict of (row,col) -> (rowspan, colspan)."""
    merges = {}
    skip = set()
    for m in merged_list:
        match = re.match(r'([A-Z]+)(\d+):([A-Z]+)(\d+)', m)
        if not match:
            continue
        c1 = col_letter_to_num(match.group(1))
        r1 = int(match.group(2))
        c2 = col_letter_to_num(match.group(3))
        r2 = int(match.group(4))
        rowspan = r2 - r1 + 1
        colspan = c2 - c1 + 1
        merges[(r1, c1)] = (rowspan, colspan)
        for r in range(r1, r2 + 1):
            for c in range(c1, c2 + 1):
                if (r, c) != (r1, c1):
                    skip.add((r, c))
    return merges, skip


def col_letter_to_num(letters):
    num = 0
    for ch in letters:
        num = num * 26 + (ord(ch) - ord('A') + 1)
    return num


# ─── Data Preprocessing ───
def preprocess_sheets():
    """Add computed subtotal rows and fix data where needed."""

    # 1. Add subtotal rows to 分渠道余额
    sheet = output_sheets.get('1、分渠道余额')
    if sheet and sheet.get('data'):
        data = sheet['data']
        new_data = list(data[:3])  # Keep headers (rows 0-2)

        # Group rows by 总分类
        groups = {}
        current_group = None
        for ri in range(3, len(data)):
            row = data[ri]
            if row[0] is not None:
                current_group = str(row[0])
            if current_group:
                if current_group not in groups:
                    groups[current_group] = []
                groups[current_group].append(row)

        grand_total = [0, 0, 0]

        for group_name in ['中低波稳健产品', '中高波市值产品', '外币产品']:
            rows = groups.get(group_name, [])
            subtotal = [0, 0]  # 行内, 行外
            for row in rows:
                v_inner = to_float(row[2])
                v_outer = to_float(row[3])
                if v_inner:
                    subtotal[0] += v_inner
                if v_outer:
                    subtotal[1] += v_outer
                new_data.append(row)

            total_val = subtotal[0] + subtotal[1]
            # Add subtotal row
            label = f'{group_name}合计'
            new_data.append([None, label, round(subtotal[0]), round(subtotal[1])])
            grand_total[0] += subtotal[0]
            grand_total[1] += subtotal[1]

        # Add 合计 column header
        if len(new_data[0]) == 4:
            new_data[0] = [None, None, '保有规模', None, None]
            new_data[1] = [None, '渠道-行内外', '行内', '行外', '合计']
            new_data[2] = ['总分类', '母分类', None, None, None]

        # Add 合计 column to each data row
        for ri in range(3, len(new_data)):
            row = new_data[ri]
            if len(row) == 4:
                v1 = to_float(row[2]) or 0
                v2 = to_float(row[3]) or 0
                row.append(round(v1 + v2))
            elif len(row) == 5:
                pass  # already has 合计

        # Add 总计 row
        new_data.append([None, '总计', round(grand_total[0]), round(grand_total[1]),
                         round(grand_total[0] + grand_total[1])])

        sheet['data'] = new_data
        sheet['col_count'] = 5

    # 2. Add 合计 row to 产品规模
    sheet = output_sheets.get('2、产品规模')
    if sheet and sheet.get('data'):
        data = sheet['data']
        # Check if 合计 row already exists
        has_total = any(str(row[0] or '').strip() in ('合计', '总计') for row in data[1:])
        if not has_total:
            totals = [0] * len(data[0])
            for row in data[1:]:
                for ci in range(2, len(row)):
                    v = to_float(row[ci])
                    if v is not None:
                        totals[ci] += v
            total_row = ['', '合计']
            for ci in range(2, len(data[0])):
                total_row.append(round(totals[ci]))
            while len(total_row) < len(data[0]):
                total_row.append(None)
            data.append(total_row)

    # 3. Add 合计 row to 投资经理维度
    sheet = output_sheets.get('投资经理维度产品规模和数量')
    if sheet and sheet.get('data'):
        data = sheet['data']
        has_total = any(str(row[0] or '').strip() in ('合计', '总计') for row in data[1:])
        if not has_total:
            totals = [0] * len(data[0])
            for row in data[1:]:
                for ci in range(1, len(row)):
                    v = to_float(row[ci])
                    if v is not None:
                        totals[ci] += v
            total_row = ['合计']
            for ci in range(1, len(data[0])):
                total_row.append(round(totals[ci], 1))
            while len(total_row) < len(data[0]):
                total_row.append(None)
            data.append(total_row)


preprocess_sheets()


# ─── Section Definitions (matching PDF TOC order) ───
SECTIONS = [
    {
        'id': 'overview',
        'title': '报告概览',
        'icon': '&#9670;',
        'sheets': ['总结文字'],
        'type': 'overview'
    },
    # ─── 一、规模及发行情况 ───
    {
        'id': 'channel-aum',
        'title': '1. 渠道代销规模',
        'icon': '&#9632;',
        'sheets': ['1、分渠道余额', '渠道明细'],
        'type': 'tables'
    },
    {
        'id': 'product-scale',
        'title': '2. 产品规模',
        'icon': '&#9632;',
        'sheets': ['2、产品规模', '不同形态产品规模和数量', '13.不同周期产品规模',
                   '14.狭义客户周期和最短持有期的产品规模跟踪'],
        'type': 'tables'
    },
    {
        'id': 'scale-changes',
        'title': '3. 在售产品销售情况',
        'icon': '&#9632;',
        'sheets': ['3、本\u2F49定开或客户周期产品规模变化', '本周新发产品', '待售产品'],
        'type': 'tables'
    },
    {
        'id': 'pm-metrics',
        'title': '4. 投资经理维度',
        'icon': '&#9632;',
        'sheets': ['投资经理维度产品规模和数量'],
        'type': 'tables'
    },
    {
        'id': 'maturity',
        'title': '5. 产品到期情况',
        'icon': '&#9670;',
        'sheets': ['10.未来全年产品到期情况', '10.未来全年产品到期情况-定开', '10.下周到期产品清单'],
        'type': 'tables'
    },
    # ─── 二、产品业绩 ───
    {
        'id': 'break-even',
        'title': '6. 破净情况',
        'icon': '&#9670;',
        'sheets': ['破净结果'],
        'type': 'tables'
    },
    {
        'id': 'market-index',
        'title': '7. 市场指数收益',
        'icon': '&#9670;',
        'sheets': ['15.市场指数收益'],
        'type': 'tables'
    },
    {
        'id': 'series-perf',
        'title': '8. 系列产品业绩',
        'icon': '&#9670;',
        'sheets': ['系列产品业绩-费前加权', '系列产品业绩-费后加权', '系列产品业绩-费前平均', '系列产品业绩-费后平均'],
        'type': 'tabs'
    },
    {
        'id': 'min-hold-perf',
        'title': '9. 最短持有期业绩',
        'icon': '&#9670;',
        'sheets': ['5.2 最短持有期产品业绩表现1', '5.2 最短持有期产品业绩表现2'],
        'type': 'tables'
    },
    {
        'id': 'underperform',
        'title': '10. 不达基准清单',
        'icon': '&#9888;',
        'sheets': ['招商在售产品不达基准', '封闭及定开产品100日内不大业绩产品清单',
                   '合享及悦动稳享临近到期预测不达标产品清单'],
        'type': 'tables'
    },
    {
        'id': 'high-vol',
        'title': '11. 高波动产品',
        'icon': '&#9888;',
        'sheets': ['12.周净值高波动产品清单'],
        'type': 'tables'
    },
    # ─── 资产与持仓 ───
    {
        'id': 'asset-alloc',
        'title': '12. 资产维度数据统计',
        'icon': '&#9679;',
        'sheets': ['8.资产大表'],
        'type': 'tables'
    },
    {
        'id': 'fee-income',
        'title': '13. 中收监控',
        'icon': '&#9679;',
        'sheets': ['9.中收监控'],
        'type': 'tables'
    },
    {
        'id': 'public-strategy',
        'title': '14. 公共策略专户',
        'icon': '&#9679;',
        'sheets': ['公共策略持仓概况'],
        'type': 'tables'
    },
    {
        'id': 'xinghe',
        'title': '15. 兴合产品持仓',
        'icon': '&#9679;',
        'sheets': ['11.兴合产品持仓明细'],
        'type': 'tables'
    },
    {
        'id': 'bond-holdings',
        'title': '16. 可转债/量化持仓',
        'icon': '&#9679;',
        'sheets': ['11.1 可转债专户持仓明细', '11.2量化和可转债持仓明细'],
        'type': 'tables'
    },
    {
        'id': 'outsource',
        'title': '17. 委外专户配置',
        'icon': '&#9679;',
        'sheets': ['11.2.1其他委外专户金额配置情况', '11.2.2其他委外专户配置占比情况',
                   '11.2.3其他委外专户配置占比情况-除以系列规模'],
        'type': 'tables'
    },
    {
        'id': 'derivatives',
        'title': '18. 衍生品/非标持仓',
        'icon': '&#9679;',
        'sheets': ['11.4其他衍生品专户持仓明细', '11.5全部衍生品专户持仓占比', '11.6非标持仓占比'],
        'type': 'tables'
    },
    {
        'id': 'gold-equity',
        'title': '19. 黄金/权益持仓',
        'icon': '&#9679;',
        'sheets': ['黄金持仓', '权益专户持仓'],
        'type': 'tables'
    },
]


# ─── Compute Overview Stats ───
def compute_overview_stats():
    stats = {}

    ps = output_sheets.get('2、产品规模', {})
    if ps.get('data'):
        total_aum = 0
        total_count = 0
        total_aum_m = 0
        total_aum_y = 0
        for row in ps['data'][1:]:
            first = str(row[0] or '').strip() if row[0] else ''
            second = str(row[1] or '').strip() if len(row) > 1 else ''
            # Skip the 合计 row we added
            if first in ('合计', '总计') or second in ('合计', '总计'):
                continue
            v = to_float(row[2]) if len(row) > 2 else None
            if v is not None:
                total_aum += v
            v = to_float(row[5]) if len(row) > 5 else None
            if v is not None:
                total_count += v
            v = to_float(row[3]) if len(row) > 3 else None
            if v is not None:
                total_aum_m += v
            v = to_float(row[4]) if len(row) > 4 else None
            if v is not None:
                total_aum_y += v
        stats['total_aum'] = total_aum
        stats['total_count'] = total_count
        stats['aum_vs_month'] = total_aum_m
        stats['aum_vs_year'] = total_aum_y

    text_sheet = output_sheets.get('总结文字', {})
    if text_sheet.get('data'):
        for row in text_sheet['data'][1:]:
            if len(row) >= 2 and row[0] and row[1]:
                key = str(row[0])
                val = str(row[1])
                if '规模' in key:
                    stats['guimo_text'] = val
                elif '中收' in key:
                    stats['zhongshou_text'] = val
                elif '到期' in key:
                    stats['daoqi_text'] = val

    bp_sheet = output_sheets.get('破净结果', {})
    if bp_sheet.get('data'):
        data_rows = [r for r in bp_sheet['data'][1:] if any(v is not None for v in r)]
        stats['broken_count'] = len(data_rows)

    up_sheet = output_sheets.get('招商在售产品不达基准', {})
    if up_sheet.get('data'):
        stats['underperform_count'] = len(up_sheet['data']) - 1

    hv_sheet = output_sheets.get('12.周净值高波动产品清单', {})
    if hv_sheet.get('data'):
        stats['high_vol_count'] = len(hv_sheet['data']) - 1

    return stats


# ─── Generate HTML Table ───
def generate_table_html(sheet_name, sheet_data, table_id=''):
    """Generate an HTML table from sheet data with formatting."""
    if not sheet_data or not sheet_data.get('data'):
        return f'<div class="empty-state">暂无数据</div>'

    data = sheet_data['data']
    merged_cells = sheet_data.get('merged_cells', [])
    merges, skip_cells = parse_merged_cells(merged_cells)
    col_types = detect_column_types(sheet_data, sheet_name)
    use_parens = sheet_name in SCALE_INT_SHEETS

    rows_html = []
    num_cols = sheet_data.get('col_count', 0)

    for ri, row in enumerate(data):
        is_header = ri == 0
        # Check if this is a sub-header row (mostly text, not data)
        is_subheader = False
        if ri in (1, 2) and ri < len(data):
            row_vals = [v for v in row if v is not None]
            numeric_count = sum(1 for v in row_vals if is_numeric(v))
            text_count = len(row_vals) - numeric_count
            if row_vals and text_count > numeric_count and text_count >= 2:
                is_subheader = True

        cells_html = []
        for ci in range(min(len(row), num_cols)):
            if (ri + 1, ci + 1) in skip_cells:
                continue

            val = row[ci]
            merge_info = merges.get((ri + 1, ci + 1))

            tag = 'th' if is_header or (is_subheader and ri < 3) else 'td'

            col_header = str(data[0][ci] or '') if ci < len(data[0]) else ''
            col_type = col_types.get(ci)

            # Format value
            if is_header or (is_subheader and ri < 3):
                display = escape_html(str(val)) if val is not None else ''
            else:
                display = format_cell_value(val, col_type, use_parens=use_parens)

            # Build attributes
            attrs = []
            css_classes = []

            if merge_info:
                rs, cs = merge_info
                if rs > 1:
                    attrs.append(f'rowspan="{rs}"')
                if cs > 1:
                    attrs.append(f'colspan="{cs}"')

            if not is_header and not is_subheader:
                cell_class = get_cell_class(val, col_type, col_header)
                if cell_class:
                    css_classes.append(cell_class)
                fval = to_float(val)
                if fval is not None:
                    css_classes.append('num-cell')

            if css_classes:
                attrs.append(f'class="{" ".join(css_classes)}"')

            attrs_str = ' ' + ' '.join(attrs) if attrs else ''
            cells_html.append(f'<{tag}{attrs_str}>{display}</{tag}>')

        # Determine row class
        row_class = 'header-row' if is_header else ('subheader-row' if is_subheader and ri < 3 else '')
        if not is_header and row:
            first_val = str(row[0] or '').strip()
            second_val = str(row[1] or '').strip() if len(row) > 1 else ''
            if first_val in ('合计', '总计', '总合计', '汇总', '总规模') or \
               second_val in ('合计', '总计', '汇总'):
                row_class = 'total-row'
            # Subtotal rows (e.g., "中低波稳健产品合计")
            elif '合计' in second_val:
                row_class = 'subtotal-row'
            # Check any of first 3 cells for 合计
            elif any('合计' in str(v or '') for v in row[:3]):
                row_class = 'total-row'

        row_class_attr = f' class="{row_class}"' if row_class else ''
        rows_html.append(f'<tr{row_class_attr}>{"".join(cells_html)}</tr>')

    tid = f' id="{table_id}"' if table_id else ''
    return f'''<div class="table-wrapper">
<table{tid}>
{"".join(rows_html)}
</table>
</div>'''


# ─── Generate Section HTML ───
def generate_section_html(section):
    parts = []

    if section['type'] == 'overview':
        stats = compute_overview_stats()
        parts.append(generate_overview_html(stats))

    elif section['type'] == 'tabs':
        tab_names = []
        tab_contents = []
        for i, sn in enumerate(section['sheets']):
            sd = output_sheets.get(sn)
            if not sd:
                continue
            # Create display-friendly tab names
            short = sn.replace('系列产品业绩-', '')
            tab_names.append(short)
            active = 'active' if i == 0 else ''
            tab_contents.append(
                f'<div class="tab-content {active}" data-tab="{section["id"]}-tab-{i}" data-tab-label="{escape_html(short)}">'
                f'{generate_table_html(sn, sd)}</div>')

        tabs_html = ''.join(
            f'<button class="tab-btn {"active" if i == 0 else ""}" '
            f'onclick="switchTab(\'{section["id"]}\', {i})" '
            f'data-tabgroup="{section["id"]}" data-tabidx="{i}">{tn}</button>'
            for i, tn in enumerate(tab_names)
        )
        parts.append(
            f'<div class="tabs-container"><div class="tab-buttons">{tabs_html}</div>'
            f'{"".join(tab_contents)}</div>')

    elif section['type'] == 'tables':
        for sn in section['sheets']:
            sd = output_sheets.get(sn)
            if not sd:
                continue
            # Display-friendly subtitle
            subtitle = sn
            parts.append(f'<h3 class="sheet-title">{escape_html(subtitle)}</h3>')
            parts.append(generate_table_html(sn, sd))

    return '\n'.join(parts)


def generate_overview_html(stats):
    aum = stats.get('total_aum')
    aum_str = f'{aum:,.0f}亿' if aum and aum > 100 else (f'{aum:,.2f}亿' if aum else 'N/A')
    count = stats.get('total_count')
    count_str = f'{int(count)}只' if count else 'N/A'
    aum_m = stats.get('aum_vs_month')
    aum_m_str = f'{aum_m:+.0f}亿' if aum_m is not None else 'N/A'
    aum_m_class = 'stat-positive' if aum_m and aum_m > 0 else ('stat-negative' if aum_m and aum_m < 0 else '')
    aum_y = stats.get('aum_vs_year')
    aum_y_str = f'{aum_y:+.0f}亿' if aum_y is not None else 'N/A'
    aum_y_class = 'stat-positive' if aum_y and aum_y > 0 else ('stat-negative' if aum_y and aum_y < 0 else '')

    broken = stats.get('broken_count', 0)
    broken_class = 'stat-alert' if broken > 0 else 'stat-ok'
    broken_str = f'{broken}只' if broken > 0 else '无'

    underperf = stats.get('underperform_count', 0)
    high_vol = stats.get('high_vol_count', 0)

    text_cards = ''
    for key, label in [('guimo_text', '规模概况'), ('zhongshou_text', '中收概况'), ('daoqi_text', '到期概况')]:
        text = stats.get(key, '')
        if text:
            text_display = escape_html(text).replace('\n', '<br>')
            text_cards += f'''<div class="text-card">
<div class="text-card-label">{label}</div>
<div class="text-card-content">{text_display}</div>
</div>'''

    # Build bar chart from 产品规模 data
    ps = output_sheets.get('2、产品规模', {})
    bar_items = []
    if ps.get('data'):
        max_aum = 0
        for row in ps['data'][1:]:
            second = str(row[1] or '').strip() if len(row) > 1 else ''
            if second in ('合计', '总计'):
                continue
            v = to_float(row[2]) if len(row) > 2 else None
            if v and v > max_aum:
                max_aum = v
        for row in ps['data'][1:]:
            name = str(row[1] or '')
            if name in ('合计', '总计'):
                continue
            v = to_float(row[2]) if len(row) > 2 else 0
            chg = to_float(row[3]) if len(row) > 3 else 0
            if v and name:
                pct = (v / max_aum * 100) if max_aum > 0 else 0
                color = 'var(--positive)' if chg and chg > 0 else (
                    'var(--negative)' if chg and chg < 0 else 'var(--accent-blue)')
                bar_items.append(f'''<div class="bar-row">
  <div class="bar-label" title="{escape_html(name)}">{escape_html(name[:8])}</div>
  <div class="bar-track"><div class="bar-fill" style="width:{pct:.1f}%;background:{color}"></div></div>
  <div class="bar-value">{v:.0f}</div>
</div>''')

    bars_html = '\n'.join(bar_items) if bar_items else ''

    return f'''
<div class="overview-grid">
  <div class="stat-card stat-primary">
    <div class="stat-label">管理规模</div>
    <div class="stat-value">{aum_str}</div>
    <div class="stat-sub">
      <span class="{aum_m_class}">较上月 {aum_m_str}</span>
      <span class="{aum_y_class}">较年初 {aum_y_str}</span>
    </div>
  </div>
  <div class="stat-card">
    <div class="stat-label">产品数量</div>
    <div class="stat-value">{count_str}</div>
  </div>
  <div class="stat-card {broken_class}">
    <div class="stat-label">破净产品</div>
    <div class="stat-value">{broken_str}</div>
  </div>
  <div class="stat-card {"stat-alert" if underperf > 3 else ""}">
    <div class="stat-label">不达基准</div>
    <div class="stat-value">{underperf}只</div>
  </div>
  <div class="stat-card {"stat-alert" if high_vol > 20 else ""}">
    <div class="stat-label">高波动产品</div>
    <div class="stat-value">{high_vol}只</div>
  </div>
</div>
<div class="overview-grid" style="grid-template-columns: 1fr 1fr;">
  <div class="stat-card" style="padding:14px 18px;">
    <div class="stat-label" style="margin-bottom:10px;">各系列规模分布 (亿)</div>
    <div class="bar-chart">{bars_html}</div>
  </div>
  <div class="stat-card" style="padding:14px 18px;">
    <div class="stat-label" style="margin-bottom:6px;">AI 摘要</div>
    <div class="text-cards-inline">
{text_cards}
    </div>
  </div>
</div>
'''


# ─── CSS Styles ───
CSS = '''
@import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Han+Sans+SC:wght@300;400;500;700&display=swap');

:root {
  --bg-primary: #050a18;
  --bg-secondary: #0c1425;
  --bg-card: #111c32;
  --bg-card-hover: #162040;
  --bg-table-header: #0f1b33;
  --bg-table-row-alt: #0a1226;
  --bg-sidebar: #080e1f;
  --bg-sidebar-active: #1a2744;

  --text-primary: #e2e8f0;
  --text-secondary: #94a3b8;
  --text-muted: #64748b;
  --text-header: #f1f5f9;

  --accent-gold: #f59e0b;
  --accent-blue: #3b82f6;
  --accent-cyan: #06b6d4;

  --positive: #10b981;
  --positive-bg: rgba(16, 185, 129, 0.08);
  --negative: #ef4444;
  --negative-bg: rgba(239, 68, 68, 0.08);
  --alert: #f97316;
  --alert-bg: rgba(249, 115, 22, 0.08);

  --border: #1e293b;
  --border-light: #1a2540;

  --sidebar-width: 260px;
  --header-height: 56px;

  --heat-pos-1: rgba(16, 185, 129, 0.1);
  --heat-pos-2: rgba(16, 185, 129, 0.2);
  --heat-pos-3: rgba(16, 185, 129, 0.3);
  --heat-pos-4: rgba(16, 185, 129, 0.45);
  --heat-pos-5: rgba(16, 185, 129, 0.6);
  --heat-neg-1: rgba(239, 68, 68, 0.1);
  --heat-neg-2: rgba(239, 68, 68, 0.2);
  --heat-neg-3: rgba(239, 68, 68, 0.3);
  --heat-neg-4: rgba(239, 68, 68, 0.45);
  --heat-neg-5: rgba(239, 68, 68, 0.6);
}

* { box-sizing: border-box; margin: 0; padding: 0; }

html {
  font-size: 13px;
  scroll-behavior: smooth;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans SC", sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  line-height: 1.5;
  overflow-x: hidden;
}

/* Header */
.top-header {
  position: fixed;
  top: 0; left: 0; right: 0;
  height: var(--header-height);
  background: linear-gradient(135deg, #0a1628 0%, #0f1d35 100%);
  border-bottom: 1px solid var(--border);
  display: flex; align-items: center;
  padding: 0 24px;
  z-index: 100;
  backdrop-filter: blur(12px);
}

.header-brand { display: flex; align-items: center; gap: 12px; }

.header-logo {
  width: 32px; height: 32px;
  background: linear-gradient(135deg, var(--accent-gold), #d97706);
  border-radius: 8px;
  display: flex; align-items: center; justify-content: center;
  font-weight: 700; font-size: 14px; color: #0a0f1c;
}

.header-title {
  font-family: "Noto Serif SC", serif;
  font-size: 16px; font-weight: 700;
  color: var(--text-header);
  letter-spacing: 1px;
}

.header-date {
  margin-left: auto;
  font-size: 12px; color: var(--text-secondary);
  background: var(--bg-card);
  padding: 4px 12px; border-radius: 4px;
  border: 1px solid var(--border);
  font-variant-numeric: tabular-nums;
}

/* Sidebar */
.sidebar {
  position: fixed;
  top: var(--header-height); left: 0; bottom: 0;
  width: var(--sidebar-width);
  background: var(--bg-sidebar);
  border-right: 1px solid var(--border);
  overflow-y: auto;
  padding: 12px 0; z-index: 90;
}

.sidebar::-webkit-scrollbar { width: 4px; }
.sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

.sidebar-section { padding: 4px 0; }

.sidebar-group-label {
  font-size: 10px; font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 1.5px;
  padding: 12px 20px 4px;
}

.nav-item {
  display: flex; align-items: center; gap: 10px;
  padding: 8px 20px;
  color: var(--text-secondary);
  text-decoration: none; font-size: 12.5px;
  cursor: pointer;
  transition: all 0.15s ease;
  border-left: 3px solid transparent;
}

.nav-item:hover { color: var(--text-primary); background: var(--bg-card); }

.nav-item.active {
  color: var(--accent-gold);
  background: var(--bg-sidebar-active);
  border-left-color: var(--accent-gold);
}

.nav-icon { font-size: 8px; opacity: 0.6; width: 14px; text-align: center; }

/* Main Content */
.main-content {
  margin-left: var(--sidebar-width);
  margin-top: var(--header-height);
  padding: 24px 28px;
  min-height: calc(100vh - var(--header-height));
}

.section {
  margin-bottom: 36px;
  scroll-margin-top: calc(var(--header-height) + 20px);
  animation: fadeInUp 0.4s ease-out;
}

.section-header {
  font-family: "Noto Serif SC", serif;
  font-size: 18px; font-weight: 700;
  color: var(--text-header);
  margin-bottom: 16px;
  padding-bottom: 10px;
  border-bottom: 2px solid var(--accent-gold);
  display: flex; align-items: center; gap: 10px;
}

.section-header::before {
  content: '';
  width: 4px; height: 20px;
  background: var(--accent-gold);
  border-radius: 2px;
}

.sheet-title {
  font-size: 13px; font-weight: 600;
  color: var(--accent-cyan);
  margin: 16px 0 8px;
  padding-left: 12px;
  border-left: 2px solid var(--accent-cyan);
}

/* Overview Cards */
.overview-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 14px; margin-bottom: 20px;
}

.stat-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 16px 18px;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.stat-card:hover { transform: translateY(-2px); box-shadow: 0 4px 20px rgba(0,0,0,0.3); }

.stat-card.stat-primary {
  border-color: var(--accent-gold);
  background: linear-gradient(135deg, rgba(245, 158, 11, 0.08), var(--bg-card));
}
.stat-card.stat-alert {
  border-color: var(--negative);
  background: linear-gradient(135deg, var(--negative-bg), var(--bg-card));
}
.stat-card.stat-ok {
  border-color: var(--positive);
  background: linear-gradient(135deg, var(--positive-bg), var(--bg-card));
}

.stat-label {
  font-size: 11px; color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px; margin-bottom: 6px;
}

.stat-value {
  font-size: 22px; font-weight: 700;
  color: var(--text-header);
  font-variant-numeric: tabular-nums;
}

.stat-sub { margin-top: 8px; display: flex; gap: 14px; font-size: 11px; }
.stat-positive { color: var(--positive); }
.stat-negative { color: var(--negative); }

.text-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 14px 18px;
}

.text-card-label {
  font-size: 11px; font-weight: 600;
  color: var(--accent-cyan);
  text-transform: uppercase;
  letter-spacing: 0.5px; margin-bottom: 8px;
}

.text-card-content {
  font-size: 12.5px; line-height: 1.7;
  color: var(--text-secondary);
}

/* Bar Chart */
.bar-chart { display: flex; flex-direction: column; gap: 4px; }
.bar-row { display: flex; align-items: center; gap: 8px; height: 18px; }
.bar-label {
  width: 80px; font-size: 10.5px;
  color: var(--text-secondary);
  text-align: right; flex-shrink: 0;
  overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.bar-track {
  flex: 1; height: 10px;
  background: var(--bg-secondary);
  border-radius: 3px; overflow: hidden;
}
.bar-fill { height: 100%; border-radius: 3px; transition: width 0.6s ease; min-width: 2px; }
.bar-value {
  width: 45px; font-size: 10.5px;
  color: var(--text-muted);
  text-align: right; font-variant-numeric: tabular-nums;
}

.text-cards-inline {
  display: flex; flex-direction: column; gap: 8px;
  max-height: 320px; overflow-y: auto;
}
.text-cards-inline .text-card { padding: 10px 14px; border-radius: 6px; }

/* Tables */
.table-wrapper {
  overflow-x: auto;
  margin: 8px 0 20px;
  border-radius: 8px;
  border: 1px solid var(--border);
  background: var(--bg-card);
}

.table-wrapper::-webkit-scrollbar { height: 6px; }
.table-wrapper::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

table {
  width: 100%; border-collapse: collapse;
  font-size: 12px; font-variant-numeric: tabular-nums;
  white-space: nowrap;
  min-width: max-content;
}

th, td {
  padding: 7px 10px;
  border-bottom: 1px solid var(--border-light);
  text-align: left;
}

th {
  background: var(--bg-table-header);
  color: var(--text-secondary);
  font-weight: 600; font-size: 11px;
  letter-spacing: 0.3px;
  position: sticky; top: 0; z-index: 2;
}

tr:nth-child(even) td { background: var(--bg-table-row-alt); }
tr:hover td { background: var(--bg-card-hover) !important; }

.num-cell {
  text-align: right;
  font-family: "SF Mono", "Cascadia Code", "JetBrains Mono", monospace;
  font-size: 11.5px;
}

.val-positive { color: var(--positive); }
.val-negative { color: var(--negative); }

.total-row td {
  font-weight: 700;
  background: rgba(245, 158, 11, 0.06) !important;
  border-top: 2px solid var(--accent-gold);
}

.subtotal-row td {
  font-weight: 600;
  background: rgba(6, 182, 212, 0.04) !important;
  border-top: 1px solid var(--accent-cyan);
  color: var(--accent-cyan);
}

td[rowspan] {
  background: var(--bg-table-header) !important;
  font-weight: 600;
  color: var(--accent-cyan);
  border-right: 2px solid var(--accent-cyan);
  vertical-align: middle;
}

th[colspan] {
  text-align: center;
  background: linear-gradient(180deg, var(--bg-table-header), rgba(15, 27, 51, 0.9));
}

/* Heatmap */
.heat-pos-1 { background: var(--heat-pos-1) !important; }
.heat-pos-2 { background: var(--heat-pos-2) !important; }
.heat-pos-3 { background: var(--heat-pos-3) !important; }
.heat-pos-4 { background: var(--heat-pos-4) !important; }
.heat-pos-5 { background: var(--heat-pos-5) !important; }
.heat-neg-1 { background: var(--heat-neg-1) !important; }
.heat-neg-2 { background: var(--heat-neg-2) !important; }
.heat-neg-3 { background: var(--heat-neg-3) !important; }
.heat-neg-4 { background: var(--heat-neg-4) !important; }
.heat-neg-5 { background: var(--heat-neg-5) !important; }

/* Tabs */
.tabs-container { margin: 8px 0 20px; }

.tab-buttons {
  display: flex; gap: 0;
  margin-bottom: -1px;
  position: relative; z-index: 3;
}

.tab-btn {
  padding: 8px 16px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-bottom: none;
  color: var(--text-secondary);
  font-size: 12px; cursor: pointer;
  border-radius: 6px 6px 0 0;
  transition: all 0.15s ease;
}

.tab-btn:hover { color: var(--text-primary); background: var(--bg-card); }
.tab-btn.active {
  color: var(--accent-gold);
  background: var(--bg-card);
  border-color: var(--accent-gold);
  border-bottom: 1px solid var(--bg-card);
}

.tab-content { display: none; }
.tab-content.active { display: block; }

.empty-state {
  padding: 32px; text-align: center;
  color: var(--text-muted); font-size: 13px;
  background: var(--bg-card);
  border-radius: 8px;
  border: 1px dashed var(--border);
}

/* Search */
.search-bar { display: flex; align-items: center; margin-left: 24px; }

.search-input {
  background: var(--bg-card);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 6px 12px; font-size: 12px;
  border-radius: 6px; width: 200px;
  outline: none; transition: border-color 0.2s;
}

.search-input:focus { border-color: var(--accent-blue); }
.search-input::placeholder { color: var(--text-muted); }

/* Upload / Export Toolbar */
.toolbar-btn {
  background: var(--bg-card);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 5px 14px; border-radius: 6px;
  font-size: 11.5px; cursor: pointer;
  transition: all 0.2s; display: inline-flex; align-items: center; gap: 6px;
}
.toolbar-btn:hover { background: var(--bg-card-hover); color: var(--text-primary); border-color: var(--accent-blue); }
.toolbar-btn svg { width: 14px; height: 14px; }
.toolbar-btn.export-btn:hover { border-color: var(--accent-gold); }
#file-upload { display: none; }

.upload-toast {
  position: fixed; top: 70px; right: 24px; z-index: 200;
  background: var(--bg-card); border: 1px solid var(--accent-blue);
  color: var(--text-primary); padding: 12px 20px; border-radius: 8px;
  font-size: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  animation: fadeInUp 0.3s ease-out;
  max-width: 400px;
}
.upload-toast.success { border-color: var(--positive); }
.upload-toast.error { border-color: var(--negative); }

/* Print / PDF Export */
@media print {
  @page {
    size: A4 landscape;
    margin: 12mm 10mm;
  }
  body {
    background: white !important; color: #111 !important;
    font-size: 9pt !important; line-height: 1.35;
  }
  .sidebar, .top-header, .toolbar-btn, #file-upload, .search-bar,
  .upload-toast { display: none !important; }
  #overview { display: none !important; }
  .main-content {
    margin: 0 !important; padding: 0 !important;
  }
  .section {
    page-break-inside: auto; margin-bottom: 8mm;
    break-before: auto;
  }
  .section-header {
    page-break-after: avoid; break-after: avoid;
    color: #111 !important; font-size: 13pt; border-left-color: #333 !important;
    margin-bottom: 4mm;
  }
  .sheet-title {
    page-break-after: avoid; break-after: avoid;
    color: #333 !important; font-size: 10pt;
  }
  .table-wrapper {
    overflow: visible !important;
    border: none !important; background: transparent !important;
    page-break-inside: auto; margin: 2mm 0 6mm;
  }
  table {
    font-size: 7.5pt !important; border: 1px solid #666;
    width: 100% !important; min-width: unset !important;
    white-space: normal !important;
  }
  th, td {
    border: 1px solid #ccc !important; padding: 2px 4px !important;
    max-width: none !important;
  }
  th {
    background: #e8e8e8 !important; color: #111 !important;
    font-weight: 700; position: static !important;
  }
  tr:nth-child(even) td { background: #f5f5f5 !important; }
  tr:hover td { background: inherit !important; }
  .total-row td {
    background: #fff3cd !important; color: #111 !important;
    font-weight: 700; border-top: 2px solid #333 !important;
  }
  .subtotal-row td {
    background: #e0f7fa !important; color: #00695c !important;
    font-weight: 600; border-top: 1px solid #00897b !important;
  }
  td[rowspan] {
    background: #f0f0f0 !important; color: #111 !important;
    border-right: 2px solid #333 !important;
  }
  .num-cell { font-family: "Courier New", monospace !important; }
  .val-positive { color: #0a7 !important; }
  .val-negative { color: #d32f2f !important; }
  [class*="heat-pos-"], [class*="heat-neg-"] { background: transparent !important; }
  .tabs-container .tab-buttons { display: none !important; }
  .tabs-container .tab-content { display: block !important; margin-bottom: 6mm; }
  .tabs-container .tab-content::before {
    content: attr(data-tab-label);
    display: block; font-weight: 700; font-size: 9pt;
    margin-bottom: 2mm; color: #333;
  }
  .stat-card { break-inside: avoid; }
  .text-card {
    background: transparent !important; border: 1px solid #ccc !important;
    color: #111 !important; break-inside: avoid;
  }
  .text-card-label { color: #333 !important; }
  .text-card-content { color: #111 !important; }
  /* Print header */
  .print-header {
    display: block !important; text-align: center;
    padding: 8mm 0 4mm; border-bottom: 2px solid #333; margin-bottom: 6mm;
  }
  .print-header h1 { font-size: 18pt; margin: 0 0 2mm; color: #111; }
  .print-header p { font-size: 10pt; color: #555; margin: 0; }
}

@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(12px); }
  to { opacity: 1; transform: translateY(0); }
}

@media (max-width: 900px) {
  .sidebar { display: none; }
  .main-content { margin-left: 0; }
}
'''

# ─── JavaScript ───
# We need to generate the section config JSON for JS
def generate_sections_json():
    import json as _json
    config = []
    for s in SECTIONS:
        config.append({
            'id': s['id'],
            'title': s['title'],
            'icon': s['icon'],
            'sheets': s['sheets'],
            'type': s['type']
        })
    return _json.dumps(config, ensure_ascii=False)


JS_TEMPLATE = '''
/* ====== Section Config ====== */
const SECTION_CONFIG = __SECTION_CONFIG__;

const SCALE_INT_SHEETS = new Set([
  '2、产品规模', '1、分渠道余额', '投资经理维度产品规模和数量',
  '不同形态产品规模和数量', '13.不同周期产品规模',
  '14.狭义客户周期和最短持有期的产品规模跟踪',
  '10.未来全年产品到期情况', '10.未来全年产品到期情况-定开'
]);
const PCT_RAW_SHEETS = new Set(['15.市场指数收益']);
const PCT_DECIMAL_SHEETS = new Set([
  '系列产品业绩-费后加权', '系列产品业绩-费后平均',
  '系列产品业绩-费前加权', '系列产品业绩-费前平均',
  '5.2 最短持有期产品业绩表现1', '5.2 最短持有期产品业绩表现2'
]);

/* ====== Sheet Name Normalization ====== */
// CJK Kangxi Radicals (U+2F00-U+2FDF) -> standard CJK equivalents
const KANGXI_MAP = {
  '\\u2F00':'\\u4E00','\\u2F01':'\\u4E28','\\u2F02':'\\u4E36','\\u2F03':'\\u4E3F','\\u2F04':'\\u4E59',
  '\\u2F05':'\\u4E85','\\u2F06':'\\u4E8C','\\u2F07':'\\u4EA0','\\u2F08':'\\u4EBA','\\u2F09':'\\u513F',
  '\\u2F0A':'\\u5165','\\u2F0B':'\\u516B','\\u2F0C':'\\u5182','\\u2F0D':'\\u5196','\\u2F0E':'\\u51AB',
  '\\u2F0F':'\\u51E0','\\u2F10':'\\u51F5','\\u2F11':'\\u5200','\\u2F12':'\\u529B','\\u2F13':'\\u52F9',
  '\\u2F14':'\\u5315','\\u2F15':'\\u531A','\\u2F16':'\\u5338','\\u2F17':'\\u5341','\\u2F18':'\\u535C',
  '\\u2F19':'\\u5369','\\u2F1A':'\\u5382','\\u2F1B':'\\u53B6','\\u2F1C':'\\u53C8','\\u2F1D':'\\u53E3',
  '\\u2F1E':'\\u56D7','\\u2F1F':'\\u571F','\\u2F20':'\\u58EB','\\u2F21':'\\u5902','\\u2F22':'\\u590A',
  '\\u2F23':'\\u5915','\\u2F24':'\\u5927','\\u2F25':'\\u5973','\\u2F26':'\\u5B50','\\u2F27':'\\u5B80',
  '\\u2F28':'\\u5BF8','\\u2F29':'\\u5C0F','\\u2F2A':'\\u5C22','\\u2F2B':'\\u5C38','\\u2F2C':'\\u5C6E',
  '\\u2F2D':'\\u5C71','\\u2F2E':'\\u5DDB','\\u2F2F':'\\u5DE5','\\u2F30':'\\u5DF1','\\u2F31':'\\u5DFE',
  '\\u2F32':'\\u5E72','\\u2F33':'\\u5E7A','\\u2F34':'\\u5E7F','\\u2F35':'\\u5EF4','\\u2F36':'\\u5EFE',
  '\\u2F37':'\\u5F13','\\u2F38':'\\u5F50','\\u2F39':'\\u5F61','\\u2F3A':'\\u5F73','\\u2F3B':'\\u5FC3',
  '\\u2F3C':'\\u6208','\\u2F3D':'\\u6236','\\u2F3E':'\\u624B','\\u2F3F':'\\u652F','\\u2F40':'\\u6534',
  '\\u2F41':'\\u6587','\\u2F42':'\\u6597','\\u2F43':'\\u65A4','\\u2F44':'\\u65B9','\\u2F45':'\\u65E0',
  '\\u2F46':'\\u65E5','\\u2F47':'\\u66F0','\\u2F48':'\\u6708','\\u2F49':'\\u6708',
  '\\u2F4A':'\\u6728','\\u2F4B':'\\u6B20','\\u2F4C':'\\u6B62','\\u2F4D':'\\u6B79','\\u2F4E':'\\u6BB3',
  '\\u2F4F':'\\u6BCB','\\u2F50':'\\u6BD4','\\u2F51':'\\u6BDB','\\u2F52':'\\u6C0F','\\u2F53':'\\u6C14',
  '\\u2F54':'\\u6C34','\\u2F55':'\\u706B','\\u2F56':'\\u722A','\\u2F57':'\\u7236','\\u2F58':'\\u723B',
  '\\u2F59':'\\u723F','\\u2F5A':'\\u7247','\\u2F5B':'\\u7259','\\u2F5C':'\\u725B','\\u2F5D':'\\u72AC'
};
function normalizeSheetName(name) {
  let result = '';
  for (let i = 0; i < name.length; i++) {
    const ch = name[i];
    result += KANGXI_MAP[ch] || ch;
  }
  return result;
}
// Build a lookup: given a sheets object, find sheet by normalized name
function findSheet(sheets, name) {
  if (sheets[name]) return sheets[name];
  const norm = normalizeSheetName(name);
  for (const key of Object.keys(sheets)) {
    if (normalizeSheetName(key) === norm) return sheets[key];
  }
  return null;
}
// Get the actual key name in sheets object
function findSheetKey(sheets, name) {
  if (sheets[name] !== undefined) return name;
  const norm = normalizeSheetName(name);
  for (const key of Object.keys(sheets)) {
    if (normalizeSheetName(key) === norm) return key;
  }
  return null;
}

/* ====== Utility Functions ====== */
function isNumeric(v) {
  if (v == null) return false;
  if (typeof v === 'number') return isFinite(v);
  if (typeof v === 'string') { const n = parseFloat(v); return !isNaN(n) && isFinite(n); }
  return false;
}
function toFloat(v) {
  if (v == null) return null;
  if (typeof v === 'number') return isFinite(v) ? v : null;
  if (typeof v === 'string') {
    if (v === '' || v === 'nan' || v === 'inf' || v === '-inf') return null;
    const n = parseFloat(v);
    return isFinite(n) ? n : null;
  }
  return null;
}
function escHtml(s) {
  if (s == null) return '';
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

/* ====== Normalized Set Matching ====== */
function setHasNorm(theSet, name) {
  if (theSet.has(name)) return true;
  const norm = normalizeSheetName(name);
  for (const item of theSet) {
    if (normalizeSheetName(item) === norm) return true;
  }
  return false;
}

/* ====== Column Type Detection ====== */
function detectColumnTypes(data, sheetName) {
  if (!data || !data[0]) return {};
  const headers = data[0];
  const colTypes = {};
  for (let ci = 0; ci < headers.length; ci++) {
    const h = String(headers[ci] || '');
    if (setHasNorm(PCT_RAW_SHEETS, sheetName)) {
      if (/年化|收益率|波动率|占比/.test(h)) { colTypes[ci] = 'percent_raw'; continue; }
    }
    if (setHasNorm(PCT_DECIMAL_SHEETS, sheetName)) {
      if (/年化|收益率|波动率|占比/.test(h)) { colTypes[ci] = 'percent'; continue; }
    }
    if (/bp/i.test(h)) { colTypes[ci] = 'bps'; continue; }
    const isPctHeader = /年化|收益率|波动率|占比|比例/.test(h);
    const numVals = [];
    for (let ri = 1; ri < Math.min(data.length, 20); ri++) {
      if (ci < data[ri].length) {
        const v = toFloat(data[ri][ci]);
        if (v != null && v !== 0) numVals.push(Math.abs(v));
      }
    }
    if (isPctHeader) {
      if (numVals.length > 0) {
        const avg = numVals.reduce((a,b) => a+b, 0) / numVals.length;
        colTypes[ci] = avg > 0.5 ? 'percent_raw' : 'percent';
      } else { colTypes[ci] = 'percent'; }
    } else if (numVals.length >= 2) {
      const avg = numVals.reduce((a,b) => a+b, 0) / numVals.length;
      const mx = Math.max(...numVals);
      if (avg > 0 && avg < 0.5 && mx < 1.5) colTypes[ci] = 'percent';
    }
  }
  return colTypes;
}

/* ====== Cell Value Formatting ====== */
function formatCellValue(val, colType, useParens) {
  if (val == null) return '';
  if (typeof val === 'string') {
    if (val === 'nan' || val === 'inf' || val === '-inf') return '';
    const n = parseFloat(val);
    if (isFinite(n)) val = n; else return escHtml(val);
  }
  if (typeof val !== 'number' || !isFinite(val)) return '';
  if (colType === 'percent') return (val * 100).toFixed(2) + '%';
  if (colType === 'percent_raw') return val.toFixed(2) + '%';
  if (colType === 'bps') return val.toFixed(2);
  if (useParens) {
    if (Math.abs(val) < 0.05) return '-';
    if (Math.abs(val) < 1 && Math.abs(val) >= 0.05)
      return val < 0 ? '(' + Math.abs(val).toFixed(1) + ')' : val.toFixed(1);
    const r = Math.round(val);
    if (r === 0) return '-';
    if (r < 0) return '(' + Math.abs(r).toLocaleString() + ')';
    return r.toLocaleString();
  }
  if (Number.isInteger(val) || (val === Math.floor(val) && Math.abs(val) < 10000)) return String(Math.floor(val));
  if (Math.abs(val) < 0.0001 && val !== 0) return val.toFixed(6);
  if (Math.abs(val) < 0.01 && val !== 0) return val.toFixed(4);
  if (Math.abs(val) < 100) return val.toFixed(2);
  if (Math.abs(val) < 100000) return val.toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2});
  return Math.round(val).toLocaleString();
}

/* ====== Cell CSS Classes ====== */
function getCellClass(val, colType, header) {
  const fval = toFloat(val);
  if (fval == null) return '';
  const h = String(header).toLowerCase();
  const classes = [];
  const isChange = /变化|较上周|较上月|较上年|bp/.test(h);
  const isReturn = /年化|收益率/.test(h);
  if (isChange) { if (fval > 0) classes.push('val-positive'); else if (fval < 0) classes.push('val-negative'); }
  if (isReturn && colType === 'percent' && fval < 0) classes.push('val-negative');
  if (isChange && fval !== 0) {
    let intensity;
    if (colType === 'percent') intensity = Math.min(Math.abs(fval) * 20, 1);
    else if (colType === 'percent_raw') intensity = Math.min(Math.abs(fval) / 5, 1);
    else if (/bp/.test(h)) intensity = Math.min(Math.abs(fval) / 50, 1);
    else intensity = Math.min(Math.abs(fval) / 20, 1);
    const level = Math.min(Math.floor(intensity * 5) + 1, 5);
    classes.push(fval > 0 ? 'heat-pos-' + level : 'heat-neg-' + level);
  }
  return classes.join(' ');
}

/* ====== Preprocessing ====== */
function preprocessSheets(sheets) {
  // 1. 分渠道余额 subtotals
  const ch = findSheet(sheets, '1、分渠道余额');
  if (ch && ch.data && ch.data.length > 3) {
    const d = ch.data;
    const newData = d.slice(0, 3);
    const groups = {};
    let curGroup = null;
    for (let ri = 3; ri < d.length; ri++) {
      const row = d[ri];
      if (row[0] != null) curGroup = String(row[0]);
      if (curGroup) { if (!groups[curGroup]) groups[curGroup] = []; groups[curGroup].push(row); }
    }
    const grandTotal = [0, 0];
    for (const gn of ['中低波稳健产品', '中高波市值产品', '外币产品']) {
      const rows = groups[gn] || [];
      const sub = [0, 0];
      for (const row of rows) {
        const v1 = toFloat(row[2]); const v2 = toFloat(row[3]);
        if (v1) sub[0] += v1; if (v2) sub[1] += v2;
        newData.push(row);
      }
      newData.push([null, gn + '合计', Math.round(sub[0]), Math.round(sub[1])]);
      grandTotal[0] += sub[0]; grandTotal[1] += sub[1];
    }
    if (newData[0].length === 4) {
      newData[0] = [null, null, '保有规模', null, null];
      newData[1] = [null, '渠道-行内外', '行内', '行外', '合计'];
      newData[2] = ['总分类', '母分类', null, null, null];
    }
    for (let ri = 3; ri < newData.length; ri++) {
      const row = newData[ri];
      if (row.length === 4) { row.push(Math.round((toFloat(row[2])||0) + (toFloat(row[3])||0))); }
    }
    newData.push([null, '总计', Math.round(grandTotal[0]), Math.round(grandTotal[1]),
                  Math.round(grandTotal[0] + grandTotal[1])]);
    ch.data = newData; ch.col_count = 5;
  }

  // 2. 产品规模 合计
  const ps = findSheet(sheets, '2、产品规模');
  if (ps && ps.data && ps.data.length > 1) {
    const d = ps.data;
    const hasTotal = d.slice(1).some(r => {
      const a = String(r[0]||'').trim(); const b = String(r[1]||'').trim();
      return a === '合计' || a === '总计' || b === '合计' || b === '总计';
    });
    if (!hasTotal) {
      const totals = new Array(d[0].length).fill(0);
      for (const row of d.slice(1)) {
        for (let ci = 2; ci < row.length; ci++) { const v = toFloat(row[ci]); if (v) totals[ci] += v; }
      }
      const totalRow = ['', '合计'];
      for (let ci = 2; ci < d[0].length; ci++) totalRow.push(Math.round(totals[ci]));
      while (totalRow.length < d[0].length) totalRow.push(null);
      d.push(totalRow);
    }
  }

  // 3. 投资经理维度 合计
  const pm = findSheet(sheets, '投资经理维度产品规模和数量');
  if (pm && pm.data && pm.data.length > 1) {
    const d = pm.data;
    const hasTotal = d.slice(1).some(r => String(r[0]||'').trim() === '合计');
    if (!hasTotal) {
      const totals = new Array(d[0].length).fill(0);
      for (const row of d.slice(1)) {
        for (let ci = 1; ci < row.length; ci++) { const v = toFloat(row[ci]); if (v) totals[ci] += v; }
      }
      const totalRow = ['合计'];
      for (let ci = 1; ci < d[0].length; ci++) totalRow.push(Math.round(totals[ci] * 10) / 10);
      while (totalRow.length < d[0].length) totalRow.push(null);
      d.push(totalRow);
    }
  }
}

/* ====== Table HTML Generation ====== */
function generateTableHTML(sheetName, sheetData) {
  if (!sheetData || !sheetData.data || sheetData.data.length === 0) return '<div class="empty-state">暂无数据</div>';
  const data = sheetData.data;
  const colTypes = detectColumnTypes(data, sheetName);
  const useParens = setHasNorm(SCALE_INT_SHEETS, sheetName);
  const numCols = sheetData.col_count || (data[0] ? data[0].length : 0);
  let html = '';
  for (let ri = 0; ri < data.length; ri++) {
    const row = data[ri];
    const isHeader = ri === 0;
    let isSubheader = false;
    if (ri === 1 || ri === 2) {
      const vals = row.filter(v => v != null);
      const numC = vals.filter(v => isNumeric(v)).length;
      if (vals.length > 0 && (vals.length - numC) > numC && (vals.length - numC) >= 2) isSubheader = true;
    }
    let cells = '';
    for (let ci = 0; ci < Math.min(row.length, numCols); ci++) {
      const val = row[ci];
      const tag = (isHeader || (isSubheader && ri < 3)) ? 'th' : 'td';
      const colH = data[0][ci] != null ? String(data[0][ci]) : '';
      const colType = colTypes[ci] || null;
      let display;
      if (isHeader || (isSubheader && ri < 3)) { display = val != null ? escHtml(String(val)) : ''; }
      else { display = formatCellValue(val, colType, useParens); }
      let cls = [];
      if (!isHeader && !isSubheader) {
        const cc = getCellClass(val, colType, colH); if (cc) cls.push(cc);
        if (toFloat(val) != null) cls.push('num-cell');
      }
      const clsStr = cls.length ? ' class="' + cls.join(' ') + '"' : '';
      cells += '<' + tag + clsStr + '>' + display + '</' + tag + '>';
    }
    let rowCls = '';
    if (isHeader) rowCls = 'header-row';
    else if (isSubheader && ri < 3) rowCls = 'subheader-row';
    else if (row.length > 0) {
      const f = String(row[0]||'').trim();
      const s = row.length > 1 ? String(row[1]||'').trim() : '';
      if (['合计','总计','总合计','汇总','总规模'].includes(f) || ['合计','总计','汇总'].includes(s))
        rowCls = 'total-row';
      else if (s.includes('合计')) rowCls = 'subtotal-row';
      else if (row.slice(0,3).some(v => String(v||'').includes('合计'))) rowCls = 'total-row';
    }
    const rcAttr = rowCls ? ' class="' + rowCls + '"' : '';
    html += '<tr' + rcAttr + '>' + cells + '</tr>';
  }
  return '<div class="table-wrapper"><table>' + html + '</table></div>';
}

/* ====== Overview Stats ====== */
function computeOverviewStats(sheets) {
  const stats = {};
  const ps = findSheet(sheets, '2、产品规模');
  if (ps && ps.data) {
    let totalAum = 0, totalCount = 0, aumM = 0, aumY = 0;
    for (const row of ps.data.slice(1)) {
      const f = String(row[0]||'').trim(); const s = String(row[1]||'').trim();
      if (['合计','总计'].includes(f) || ['合计','总计'].includes(s)) continue;
      let v = toFloat(row[2]); if (v) totalAum += v;
      v = toFloat(row[5]); if (v) totalCount += v;
      v = toFloat(row[3]); if (v) aumM += v;
      v = toFloat(row[4]); if (v) aumY += v;
    }
    stats.totalAum = totalAum; stats.totalCount = totalCount;
    stats.aumM = aumM; stats.aumY = aumY;
  }
  const ts = findSheet(sheets, '总结文字');
  if (ts && ts.data) {
    for (const row of ts.data.slice(1)) {
      if (row.length >= 2 && row[0] && row[1]) {
        const k = String(row[0]); const v = String(row[1]);
        if (k.includes('规模')) stats.guimoText = v;
        else if (k.includes('中收')) stats.zhongshouText = v;
        else if (k.includes('到期')) stats.daoqiText = v;
      }
    }
  }
  const bp = findSheet(sheets, '破净结果');
  if (bp && bp.data) stats.brokenCount = bp.data.slice(1).filter(r => r.some(v => v != null)).length;
  const up = findSheet(sheets, '招商在售产品不达基准');
  if (up && up.data) stats.underperformCount = up.data.length - 1;
  const hv = findSheet(sheets, '12.周净值高波动产品清单');
  if (hv && hv.data) stats.highVolCount = hv.data.length - 1;
  return stats;
}

function generateOverviewHTML(stats, sheets) {
  const aum = stats.totalAum;
  const aumStr = aum > 100 ? Math.round(aum).toLocaleString() + '亿' : (aum ? aum.toFixed(2) + '亿' : 'N/A');
  const countStr = stats.totalCount ? Math.round(stats.totalCount) + '只' : 'N/A';
  const aumMStr = stats.aumM != null ? (stats.aumM >= 0 ? '+' : '') + Math.round(stats.aumM) + '亿' : 'N/A';
  const aumMCls = stats.aumM > 0 ? 'stat-positive' : (stats.aumM < 0 ? 'stat-negative' : '');
  const aumYStr = stats.aumY != null ? (stats.aumY >= 0 ? '+' : '') + Math.round(stats.aumY) + '亿' : 'N/A';
  const aumYCls = stats.aumY > 0 ? 'stat-positive' : (stats.aumY < 0 ? 'stat-negative' : '');
  const broken = stats.brokenCount || 0;
  const brokenCls = broken > 0 ? 'stat-alert' : 'stat-ok';
  const brokenStr = broken > 0 ? broken + '只' : '无';
  const underperf = stats.underperformCount || 0;
  const highVol = stats.highVolCount || 0;
  let textCards = '';
  for (const [key, label] of [['guimoText','规模概况'],['zhongshouText','中收概况'],['daoqiText','到期概况']]) {
    const text = stats[key] || '';
    if (text) textCards += '<div class="text-card"><div class="text-card-label">' + label +
      '</div><div class="text-card-content">' + escHtml(text).replace(/\\n/g, '<br>') + '</div></div>';
  }
  // Bar chart
  let barItems = '';
  const ps = findSheet(sheets, '2、产品规模');
  if (ps && ps.data) {
    let maxAum = 0;
    for (const row of ps.data.slice(1)) {
      const s = String(row[1]||'').trim();
      if (['合计','总计'].includes(s)) continue;
      const v = toFloat(row[2]); if (v && v > maxAum) maxAum = v;
    }
    for (const row of ps.data.slice(1)) {
      const name = String(row[1] || '');
      if (['合计','总计'].includes(name.trim())) continue;
      const v = toFloat(row[2]) || 0;
      const chg = toFloat(row[3]) || 0;
      if (v && name) {
        const pct = maxAum > 0 ? (v / maxAum * 100) : 0;
        const color = chg > 0 ? 'var(--positive)' : (chg < 0 ? 'var(--negative)' : 'var(--accent-blue)');
        barItems += '<div class="bar-row"><div class="bar-label" title="'+escHtml(name)+'">'+escHtml(name.slice(0,8))+
          '</div><div class="bar-track"><div class="bar-fill" style="width:'+pct.toFixed(1)+'%;background:'+color+
          '"></div></div><div class="bar-value">'+Math.round(v)+'</div></div>';
      }
    }
  }
  return '<div class="overview-grid">'+
    '<div class="stat-card stat-primary"><div class="stat-label">管理规模</div><div class="stat-value">'+aumStr+'</div>'+
    '<div class="stat-sub"><span class="'+aumMCls+'">较上月 '+aumMStr+'</span> <span class="'+aumYCls+'">较年初 '+aumYStr+'</span></div></div>'+
    '<div class="stat-card"><div class="stat-label">产品数量</div><div class="stat-value">'+countStr+'</div></div>'+
    '<div class="stat-card '+brokenCls+'"><div class="stat-label">破净产品</div><div class="stat-value">'+brokenStr+'</div></div>'+
    '<div class="stat-card '+(underperf>3?'stat-alert':'')+'"><div class="stat-label">不达基准</div><div class="stat-value">'+underperf+'只</div></div>'+
    '<div class="stat-card '+(highVol>20?'stat-alert':'')+'"><div class="stat-label">高波动产品</div><div class="stat-value">'+highVol+'只</div></div>'+
    '</div>'+
    '<div class="overview-grid" style="grid-template-columns:1fr 1fr;">'+
    '<div class="stat-card" style="padding:14px 18px"><div class="stat-label" style="margin-bottom:10px">各系列规模分布 (亿)</div><div class="bar-chart">'+barItems+'</div></div>'+
    '<div class="stat-card" style="padding:14px 18px"><div class="stat-label" style="margin-bottom:6px">AI 摘要</div><div class="text-cards-inline">'+textCards+'</div></div>'+
    '</div>';
}

/* ====== Rebuild Dashboard ====== */
function rebuildDashboard(sheets) {
  for (const section of SECTION_CONFIG) {
    const el = document.getElementById(section.id);
    if (!el) continue;
    // Keep the section header
    const header = el.querySelector('.section-header');
    const headerHTML = header ? header.outerHTML : '<h2 class="section-header">' + escHtml(section.title) + '</h2>';
    let contentHTML = '';

    if (section.type === 'overview') {
      const stats = computeOverviewStats(sheets);
      contentHTML = generateOverviewHTML(stats, sheets);
    } else if (section.type === 'tabs') {
      let tabBtns = '', tabContents = '';
      let tabIdx = 0;
      for (const sn of section.sheets) {
        const sd = findSheet(sheets, sn);
        if (!sd) continue;
        const short = sn.replace('系列产品业绩-', '');
        const active = tabIdx === 0 ? ' active' : '';
        const actualKey = findSheetKey(sheets, sn) || sn;
        tabBtns += '<button class="tab-btn'+active+'" onclick="switchTab(\\''+section.id+'\\','+tabIdx+')" '+
          'data-tabgroup="'+section.id+'" data-tabidx="'+tabIdx+'">'+escHtml(short)+'</button>';
        tabContents += '<div class="tab-content'+active+'" data-tab="'+section.id+'-tab-'+tabIdx+'" data-tab-label="'+escHtml(short)+'">'+
          generateTableHTML(actualKey, sd)+'</div>';
        tabIdx++;
      }
      contentHTML = '<div class="tabs-container"><div class="tab-buttons">'+tabBtns+'</div>'+tabContents+'</div>';
    } else {
      for (const sn of section.sheets) {
        const sd = findSheet(sheets, sn);
        if (!sd) continue;
        const actualKey = findSheetKey(sheets, sn) || sn;
        contentHTML += '<h3 class="sheet-title">'+escHtml(actualKey)+'</h3>' + generateTableHTML(actualKey, sd);
      }
    }
    el.innerHTML = headerHTML + contentHTML;
  }
  // Re-init table sort
  initTableSort();
}

/* ====== File Upload Handler ====== */
function showToast(msg, type) {
  const existing = document.querySelectorAll('.upload-toast');
  existing.forEach(e => e.remove());
  const toast = document.createElement('div');
  toast.className = 'upload-toast ' + (type || '');
  toast.innerHTML = msg;
  document.body.appendChild(toast);
  setTimeout(() => toast.remove(), 5000);
}

async function handleFileUpload(e) {
  const file = e.target.files[0];
  if (!file) return;
  if (!file.name.endsWith('.xlsx') && !file.name.endsWith('.xls')) {
    showToast('请上传 .xlsx 格式的Excel文件', 'error');
    return;
  }
  showToast('正在解析 ' + escHtml(file.name) + ' ...', '');
  try {
    const arrayBuf = await file.arrayBuffer();
    const wb = XLSX.read(arrayBuf, { type: 'array' });
    const sheets = {};
    for (const name of wb.SheetNames) {
      const ws = wb.Sheets[name];
      const jsonData = XLSX.utils.sheet_to_json(ws, { header: 1, defval: null, raw: true });
      // Get merged cells
      const mergedCells = (ws['!merges'] || []).map(m => XLSX.utils.encode_range(m));
      sheets[name] = {
        data: jsonData,
        col_count: jsonData[0] ? jsonData[0].length : 0,
        merged_cells: mergedCells
      };
    }
    // Preprocess
    preprocessSheets(sheets);
    // Rebuild
    rebuildDashboard(sheets);
    // Update date from filename
    const dateMatch = file.name.match(/(\\d{8})/);
    if (dateMatch) {
      const d = dateMatch[1];
      const dateStr = d.slice(0,4) + '-' + d.slice(4,6) + '-' + d.slice(6,8);
      document.querySelectorAll('.header-date').forEach(el => el.textContent = '数据截止 ' + dateStr);
      document.querySelectorAll('footer').forEach(el => {
        el.innerHTML = '兴银理财多资产投资部 | 数据截止 ' + dateStr + ' | 仪表板更新于 ' + new Date().toLocaleString('zh-CN');
      });
    }
    showToast('数据导入成功！已加载 ' + wb.SheetNames.length + ' 张工作表', 'success');
  } catch (err) {
    console.error(err);
    showToast('解析失败: ' + escHtml(err.message), 'error');
  }
  e.target.value = '';
}

/* ====== PDF Export ====== */
function exportPDF() {
  // Add tab labels for print mode (show all tabs)
  document.querySelectorAll('.tab-content').forEach(tc => {
    if (!tc.getAttribute('data-tab-label')) {
      const tabGroup = tc.getAttribute('data-tab');
      if (tabGroup) {
        const idx = tabGroup.split('-tab-')[1];
        const btn = document.querySelector('[data-tabgroup="' + tabGroup.split('-tab-')[0] + '"][data-tabidx="' + idx + '"]');
        if (btn) tc.setAttribute('data-tab-label', btn.textContent);
      }
    }
  });
  window.print();
}

/* ====== Core UI Init ====== */
function switchTab(groupId, tabIdx) {
  document.querySelectorAll('[data-tabgroup="'+groupId+'"]').forEach(btn => btn.classList.remove('active'));
  document.querySelectorAll('[data-tab^="'+groupId+'-tab-"]').forEach(c => c.classList.remove('active'));
  document.querySelector('[data-tabgroup="'+groupId+'"][data-tabidx="'+tabIdx+'"]').classList.add('active');
  document.querySelector('[data-tab="'+groupId+'-tab-'+tabIdx+'"]').classList.add('active');
}

function initNavHighlight() {
  const sections = document.querySelectorAll('.section');
  const navItems = document.querySelectorAll('.nav-item');
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const id = entry.target.id;
        navItems.forEach(item => {
          item.classList.toggle('active', item.getAttribute('href') === '#' + id);
        });
      }
    });
  }, { threshold: 0.1, rootMargin: '-80px 0px -50% 0px' });
  sections.forEach(s => observer.observe(s));
  navItems.forEach(item => {
    item.addEventListener('click', (e) => {
      e.preventDefault();
      const targetId = item.getAttribute('href').substring(1);
      const target = document.getElementById(targetId);
      if (target) {
        const hh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--header-height')) || 56;
        const y = target.getBoundingClientRect().top + window.pageYOffset - hh - 20;
        window.scrollTo({ top: y, behavior: 'smooth' });
        history.pushState(null, null, '#' + targetId);
      }
    });
  });
}

function initSearch() {
  const input = document.getElementById('global-search');
  if (!input) return;
  input.addEventListener('input', (e) => {
    const query = e.target.value.toLowerCase().trim();
    document.querySelectorAll('table').forEach(table => {
      table.querySelectorAll('tr:not(.header-row):not(.subheader-row)').forEach(row => {
        if (!query) { row.style.display = ''; return; }
        row.style.display = row.textContent.toLowerCase().includes(query) ? '' : 'none';
      });
    });
  });
}

function initTableSort() {
  document.querySelectorAll('th').forEach(th => {
    th.style.cursor = 'pointer';
    th.addEventListener('click', () => {
      const table = th.closest('table');
      const idx = Array.from(th.parentNode.children).indexOf(th);
      const tbody = table.querySelector('tbody') || table;
      const rows = Array.from(tbody.querySelectorAll('tr')).filter(r =>
        !r.classList.contains('header-row') && !r.classList.contains('subheader-row') &&
        !r.classList.contains('total-row') && !r.classList.contains('subtotal-row'));
      const isAsc = th.getAttribute('data-sort') !== 'asc';
      th.setAttribute('data-sort', isAsc ? 'asc' : 'desc');
      rows.sort((a, b) => {
        const aVal = a.children[idx]?.textContent?.trim()?.replace(/[()]/g, '') || '';
        const bVal = b.children[idx]?.textContent?.trim()?.replace(/[()]/g, '') || '';
        const aNum = parseFloat(aVal.replace(/[,%亿万只]/g, ''));
        const bNum = parseFloat(bVal.replace(/[,%亿万只]/g, ''));
        if (!isNaN(aNum) && !isNaN(bNum)) return isAsc ? aNum - bNum : bNum - aNum;
        return isAsc ? aVal.localeCompare(bVal, 'zh') : bVal.localeCompare(aVal, 'zh');
      });
      rows.forEach(r => tbody.appendChild(r));
    });
  });
}

document.addEventListener('DOMContentLoaded', () => {
  initNavHighlight();
  initSearch();
  initTableSort();
  // Bind upload
  const uploadInput = document.getElementById('file-upload');
  if (uploadInput) uploadInput.addEventListener('change', handleFileUpload);
});
'''


# ─── Assemble HTML ───
def generate_html():
    # Sidebar navigation - grouped to match PDF structure
    groups = {
        '一、规模及发行': ['overview', 'channel-aum', 'product-scale', 'scale-changes', 'pm-metrics', 'maturity'],
        '二、产品业绩': ['break-even', 'market-index', 'series-perf', 'min-hold-perf', 'underperform', 'high-vol'],
        '三、资产与持仓': ['asset-alloc', 'fee-income', 'public-strategy', 'xinghe', 'bond-holdings',
                     'outsource', 'derivatives', 'gold-equity'],
    }

    section_map = {s['id']: s for s in SECTIONS}

    nav_html = ''
    for group_name, section_ids in groups.items():
        nav_html += f'<div class="sidebar-section"><div class="sidebar-group-label">{group_name}</div>'
        for sid in section_ids:
            sec = section_map.get(sid)
            if sec:
                nav_html += (f'<a class="nav-item" href="#{sid}">'
                             f'<span class="nav-icon">{sec["icon"]}</span>{sec["title"]}</a>')
        nav_html += '</div>'

    # Main content sections
    content_html = ''
    for section in SECTIONS:
        section_content = generate_section_html(section)
        content_html += f'''<div class="section" id="{section['id']}">
<h2 class="section-header">{escape_html(section['title'])}</h2>
{section_content}
</div>'''

    from datetime import datetime
    now = datetime.now().strftime('%Y-%m-%d %H:%M')

    sections_json = generate_sections_json()
    js_code = JS_TEMPLATE.replace('__SECTION_CONFIG__', sections_json)

    html = f'''<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>{REPORT_TITLE} - {REPORT_DATE}</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<style>
{CSS}
</style>
</head>
<body>

<!-- Print-only header -->
<div class="print-header" style="display:none;">
  <h1>{REPORT_TITLE}</h1>
  <p class="header-date">数据截止 {REPORT_DATE}</p>
</div>

<header class="top-header">
  <div class="header-brand">
    <div class="header-logo">XY</div>
    <div class="header-title">{REPORT_TITLE}</div>
  </div>
  <div class="search-bar">
    <input type="text" id="global-search" class="search-input" placeholder="搜索产品/经理/代码...">
  </div>
  <div style="display:flex;align-items:center;gap:8px;margin-left:auto;">
    <input type="file" id="file-upload" accept=".xlsx,.xls">
    <button class="toolbar-btn" onclick="document.getElementById('file-upload').click()" title="导入Excel数据文件">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
      导入数据
    </button>
    <button class="toolbar-btn export-btn" onclick="exportPDF()" title="导出为PDF周报">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>
      导出周报
    </button>
    <div class="header-date">数据截止 {REPORT_DATE}</div>
  </div>
</header>

<nav class="sidebar">
{nav_html}
</nav>

<main class="main-content">
{content_html}
<footer style="text-align:center;padding:24px;color:var(--text-muted);font-size:11px;border-top:1px solid var(--border);margin-top:40px;">
  兴银理财多资产投资部 | 数据截止 {REPORT_DATE} | 仪表板生成于 {now}
</footer>
</main>

<script>
{js_code}
</script>
</body>
</html>'''

    return html


# ─── Main ───
if __name__ == '__main__':
    print('Generating dashboard HTML...')
    html = generate_html()

    with open(OUTPUT_HTML, 'w', encoding='utf-8') as f:
        f.write(html)

    file_size = os.path.getsize(OUTPUT_HTML)
    print(f'Dashboard generated: {OUTPUT_HTML}')
    print(f'File size: {file_size:,} bytes ({file_size/1024:.1f} KB)')
    print(f'Sections: {len(SECTIONS)}')
    print(f'Total sheets displayed: {sum(len(s["sheets"]) for s in SECTIONS)}')
