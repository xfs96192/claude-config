"""iChoice/EMQuantAPI data fetcher with proper timeout handling"""
import pandas as pd
import logging
from typing import List, Dict, Optional, Tuple
from datetime import datetime
import tempfile
import os
import subprocess
import sys

logger = logging.getLogger(__name__)


class IChoiceClient:
    """Client for fetching data from iChoice/EMQuantAPI"""

    def __init__(self, sdk_path: str, username: str, password: str, timeout: int = 300000):
        """Initialize iChoice client

        Args:
            sdk_path: Path to EMQuantAPI Python SDK
            username: iChoice username
            password: iChoice password
            timeout: Timeout in milliseconds (default 5 min for initial login)
        """
        self.sdk_path = sdk_path
        self.username = username
        self.password = password
        self.timeout = timeout

    def determine_data_source(self, ichoice_code: str) -> str:
        """Determine if code uses EDB or CSD API

        Args:
            ichoice_code: iChoice indicator code

        Returns:
            'EDB' for macro/economic data, 'CSD' for market data, 'UNKNOWN' otherwise
        """
        if ichoice_code.startswith(('EMM', 'EMG', 'EMI', 'E')):
            return 'EDB'
        elif '.' in ichoice_code:  # Has exchange suffix
            return 'CSD'
        else:
            return 'UNKNOWN'

    def _create_python_script(self, script_content: str) -> str:
        """Create temporary Python script file

        Args:
            script_content: Python code to execute

        Returns:
            Path to temporary script file
        """
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
            f.write(script_content)
            return f.name

    def _execute_script(self, script_path: str) -> str:
        """Execute Python script via subprocess with proper timeout

        Args:
            script_path: Path to Python script

        Returns:
            Script output as string
        """
        try:
            # Execute with timeout (in seconds, so convert from ms)
            result = subprocess.run(
                [sys.executable, script_path],
                capture_output=True,
                text=True,
                timeout=self.timeout / 1000  # Convert ms to seconds
            )

            if result.returncode != 0:
                error_msg = result.stderr if result.stderr else result.stdout
                raise RuntimeError(f"Script execution failed: {error_msg}")

            return result.stdout

        except subprocess.TimeoutExpired:
            raise TimeoutError(f"Script execution exceeded {self.timeout}ms timeout")
        finally:
            # Clean up temporary file
            if os.path.exists(script_path):
                try:
                    os.unlink(script_path)
                except Exception:
                    pass  # Ignore cleanup errors

    def fetch_edb_data(self, codes: List[str], start_date: str,
                       end_date: str) -> Dict[str, pd.DataFrame]:
        """Fetch EDB data (macro/economic indicators)

        Args:
            codes: List of EDB indicator codes (max 100)
            start_date: Start date (YYYY-MM-DD)
            end_date: End date (YYYY-MM-DD)

        Returns:
            Dictionary mapping code to DataFrame with columns: date, value
        """
        if len(codes) > 100:
            raise ValueError("EDB API supports max 100 indicators per request")

        # Create Python script for EDB fetch
        script = f"""
import sys
sys.path.insert(0, '{self.sdk_path}')
from EmQuantAPI import c
import pandas as pd

# Login (use correct format from skill)
result = c.start("UserName={self.username},Password={self.password},ForceLogin=1")
if result.ErrorCode != 0:
    print(f"LOGIN_ERROR: {{result.ErrorMsg}}")
    sys.exit(1)

try:
    # Fetch EDB data (Ispandas=1 returns DataFrame directly)
    codes = "{','.join(codes)}"
    params = "StartDate={start_date},EndDate={end_date},Ispandas=1"
    data = c.edb(codes, params)

    # Check if it's an error object or DataFrame
    if hasattr(data, 'ErrorCode') and data.ErrorCode != 0:
        print(f"FETCH_ERROR: {{data.ErrorMsg}}")
        sys.exit(1)

    # If it's a DataFrame, save it
    if isinstance(data, pd.DataFrame):
        data.to_csv('/tmp/ichoice_edb_result.csv', index=False)
        print("SUCCESS")
    else:
        print(f"FETCH_ERROR: Unexpected return type")
        sys.exit(1)

finally:
    c.stop()
"""

        script_path = self._create_python_script(script)

        try:
            output = self._execute_script(script_path)

            if "SUCCESS" not in output:
                raise RuntimeError(f"EDB fetch failed: {output}")

            # Load results from CSV
            df = pd.read_csv('/tmp/ichoice_edb_result.csv')

            # Parse into dict by code
            # EDB returns columns: DATES, code1, code2, ...
            result = {}
            for code in codes:
                if code in df.columns:
                    code_df = pd.DataFrame({
                        'date': pd.to_datetime(df['DATES']).dt.strftime('%Y-%m-%d'),
                        'value': df[code]
                    })
                    # Remove NaN values
                    code_df = code_df.dropna()
                    result[code] = code_df
                else:
                    logger.warning(f"Code {code} not found in EDB result")
                    result[code] = pd.DataFrame(columns=['date', 'value'])

            return result

        except Exception as e:
            logger.error(f"EDB fetch error for {codes}: {e}")
            raise

    def fetch_csd_data(self, code: str, field: str, start_date: str,
                       end_date: str) -> pd.DataFrame:
        """Fetch CSD data (market time series)

        Args:
            code: Security code (e.g., "000300.SH")
            field: Field name (e.g., "CLOSE", "PETTM")
            start_date: Start date (YYYY-MM-DD)
            end_date: End date (YYYY-MM-DD)

        Returns:
            DataFrame with columns: date, value
        """
        # Create Python script for CSD fetch
        script = f"""
import sys
sys.path.insert(0, '{self.sdk_path}')
from EmQuantAPI import c
import pandas as pd

# Login (use correct format from skill)
result = c.start("UserName={self.username},Password={self.password},ForceLogin=1")
if result.ErrorCode != 0:
    print(f"LOGIN_ERROR: {{result.ErrorMsg}}")
    sys.exit(1)

try:
    # Fetch CSD data (Ispandas=1 returns DataFrame directly)
    data = c.csd('{code}', '{field}', '{start_date}', '{end_date}', 'Ispandas=1')

    # Check if it's an error object or DataFrame
    if hasattr(data, 'ErrorCode') and data.ErrorCode != 0:
        print(f"FETCH_ERROR: {{data.ErrorMsg}}")
        sys.exit(1)

    # If it's a DataFrame, save it
    if isinstance(data, pd.DataFrame):
        data.to_csv('/tmp/ichoice_csd_result.csv', index=False)
        print("SUCCESS")
    else:
        print(f"FETCH_ERROR: Unexpected return type")
        sys.exit(1)

finally:
    c.stop()
"""

        script_path = self._create_python_script(script)

        try:
            output = self._execute_script(script_path)

            if "SUCCESS" not in output:
                raise RuntimeError(f"CSD fetch failed: {output}")

            # Load results from CSV
            df = pd.read_csv('/tmp/ichoice_csd_result.csv')

            # CSD returns columns: DATES, code (field value)
            if len(df.columns) < 2:
                logger.warning(f"CSD returned insufficient columns for {code}.{field}")
                return pd.DataFrame(columns=['date', 'value'])

            # Convert date format: YYYY/MM/DD -> YYYY-MM-DD
            dates_col = df.columns[0]  # Usually 'DATES'
            value_col = df.columns[1]   # The field value column

            result_df = pd.DataFrame({
                'date': pd.to_datetime(df[dates_col]).dt.strftime('%Y-%m-%d'),
                'value': df[value_col]
            })

            # Remove NaN values
            result_df = result_df.dropna()

            return result_df

        except Exception as e:
            logger.error(f"CSD fetch error for {code}.{field}: {e}")
            raise

    def fetch_indicator_data(self, ichoice_code: str, field_name: str,
                            start_date: str, end_date: str) -> pd.DataFrame:
        """Unified method to fetch data for any indicator

        Args:
            ichoice_code: iChoice indicator code
            field_name: Field name ("value" for EDB, specific field for CSD)
            start_date: Start date (YYYY-MM-DD)
            end_date: End date (YYYY-MM-DD)

        Returns:
            DataFrame with columns: date, value
        """
        data_source = self.determine_data_source(ichoice_code)

        if data_source == 'EDB':
            # EDB data (single indicator)
            result_dict = self.fetch_edb_data([ichoice_code], start_date, end_date)
            return result_dict.get(ichoice_code, pd.DataFrame(columns=['date', 'value']))

        elif data_source == 'CSD':
            # CSD data with specific field
            return self.fetch_csd_data(ichoice_code, field_name, start_date, end_date)

        else:
            raise ValueError(f"Unknown data source for code: {ichoice_code}")

    def test_connection(self) -> bool:
        """Test iChoice API connection

        Returns:
            True if connection successful, False otherwise
        """
        script = f"""
import sys
sys.path.insert(0, '{self.sdk_path}')
from EmQuantAPI import c

result = c.start("UserName={self.username},Password={self.password},ForceLogin=1")

if result.ErrorCode == 0:
    print("CONNECTION_SUCCESS")
    c.stop()
    sys.exit(0)
else:
    print(f"CONNECTION_FAILED: {{result.ErrorMsg}}")
    sys.exit(1)
"""

        script_path = self._create_python_script(script)

        try:
            output = self._execute_script(script_path)
            return "CONNECTION_SUCCESS" in output
        except Exception as e:
            logger.error(f"Connection test failed: {e}")
            return False
