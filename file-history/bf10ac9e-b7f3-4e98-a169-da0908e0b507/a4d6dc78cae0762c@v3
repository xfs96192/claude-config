"""Load indicator metadata from Excel file"""
import pandas as pd
import logging
from typing import List, Dict, Tuple

logger = logging.getLogger(__name__)


class IndicatorLoader:
    """Load and parse indicator definitions from Excel"""

    def __init__(self, excel_path: str):
        """Initialize indicator loader

        Args:
            excel_path: Path to indicator Excel file (数据指标.xlsx)
        """
        self.excel_path = excel_path

    def determine_data_source(self, ichoice_code: str) -> str:
        """Determine data source based on code pattern

        Args:
            ichoice_code: iChoice indicator code

        Returns:
            'EDB' for macro/economic data, 'CSD' for market data
        """
        if pd.isna(ichoice_code) or not ichoice_code:
            return 'UNKNOWN'

        ichoice_code = str(ichoice_code).strip()

        if ichoice_code.startswith(('EMM', 'EMG', 'EMI', 'E')):
            return 'EDB'
        elif '.' in ichoice_code:  # Has exchange suffix
            return 'CSD'
        else:
            return 'UNKNOWN'

    def determine_fields(self, ichoice_code: str, data_source: str,
                        category: str) -> List[Tuple[str, str]]:
        """Determine fields for an indicator

        Args:
            ichoice_code: iChoice indicator code
            data_source: Data source (EDB/CSD)
            category: Indicator category

        Returns:
            List of (field_name, field_display_name) tuples
        """
        if data_source == 'EDB':
            # EDB indicators always have single "value" field
            return [('value', '数值')]

        elif data_source == 'CSD':
            # CSD indicators: determine fields based on type
            fields = []

            # Stock indices and Shenwan industries: CLOSE + PETTM
            if (ichoice_code.endswith(('.SH', '.SZ', '.CSI')) or
                ichoice_code.startswith('801') and ichoice_code.endswith('.SWI')):
                # Check if it's an equity index (not bond/commodity)
                if category in ['权益', '海外']:
                    fields.append(('CLOSE', '收盘价'))
                    fields.append(('PETTM', '市盈率TTM'))
                else:
                    # Bond/commodity indices: just CLOSE
                    fields.append(('CLOSE', '收盘价'))

            # Rates, FX, commodities: typically just CLOSE
            elif category in ['资金', '外汇', '商品', '可转债']:
                fields.append(('CLOSE', '收盘价'))

            # Default: CLOSE only
            if not fields:
                fields.append(('CLOSE', '收盘价'))

            return fields

        else:
            # Unknown source: default to single value field
            return [('value', '数值')]

    def load_indicators(self) -> List[Dict]:
        """Load indicators from Excel file

        Returns:
            List of indicator dictionaries with metadata
        """
        logger.info(f"Loading indicators from {self.excel_path}")

        try:
            # Read Excel file
            df = pd.read_excel(self.excel_path)

            logger.info(f"Excel file loaded: {len(df)} rows")
            logger.info(f"Columns: {df.columns.tolist()}")

            indicators = []

            # Parse each row
            for idx, row in df.iterrows():
                try:
                    # Extract fields from actual Excel columns
                    # Columns: 指标类别, 指标名称, wind代码, wind字段, choice代码, choice字段, choice插件函数

                    # Try different possible column names
                    category = None
                    for col in ['指标类别', '分类', '类别', '数据类别', 'category']:
                        if col in df.columns and not pd.isna(row.get(col)):
                            category = str(row[col]).strip()
                            break

                    name = None
                    for col in ['指标名称', '名称', '指标', 'name']:
                        if col in df.columns and not pd.isna(row.get(col)):
                            name = str(row[col]).strip()
                            break

                    ichoice_code = None
                    for col in ['choice代码', 'Choice代码', '东财代码', 'iChoice代码', 'choice_code', 'ichoice_code']:
                        if col in df.columns and not pd.isna(row.get(col)):
                            ichoice_code = str(row[col]).strip()
                            break

                    # Skip if essential fields are missing
                    if not ichoice_code or ichoice_code == 'nan':
                        logger.debug(f"Skipping row {idx}: no iChoice code")
                        continue

                    if not category:
                        category = '未分类'
                        logger.debug(f"Row {idx}: using default category")

                    if not name:
                        name = ichoice_code
                        logger.debug(f"Row {idx}: using code as name")

                    # Determine data source and fields
                    data_source = self.determine_data_source(ichoice_code)

                    if data_source == 'UNKNOWN':
                        logger.warning(f"Unknown data source for {ichoice_code}, skipping")
                        continue

                    fields = self.determine_fields(ichoice_code, data_source, category)

                    indicator = {
                        'category': category,
                        'name': name,
                        'ichoice_code': ichoice_code,
                        'data_source': data_source,
                        'fields': fields
                    }

                    indicators.append(indicator)

                except Exception as e:
                    logger.error(f"Error parsing row {idx}: {e}")
                    continue

            logger.info(f"Successfully parsed {len(indicators)} indicators")

            # Log statistics
            sources = {}
            categories = {}
            for ind in indicators:
                sources[ind['data_source']] = sources.get(ind['data_source'], 0) + 1
                categories[ind['category']] = categories.get(ind['category'], 0) + 1

            logger.info(f"Data sources: {sources}")
            logger.info(f"Categories: {categories}")

            return indicators

        except Exception as e:
            logger.error(f"Failed to load indicators from Excel: {e}")
            raise

    def populate_database(self, db) -> Tuple[int, int]:
        """Load indicators into database

        Args:
            db: Database instance

        Returns:
            Tuple of (indicators_count, fields_count)
        """
        indicators = self.load_indicators()

        indicators_count = 0
        fields_count = 0

        for indicator in indicators:
            # Insert indicator
            result = db.insert_indicator(
                category=indicator['category'],
                name=indicator['name'],
                ichoice_code=indicator['ichoice_code'],
                data_source=indicator['data_source']
            )

            if result > 0:
                indicators_count += 1

                # Insert fields
                for field_name, field_display_name in indicator['fields']:
                    field_result = db.insert_indicator_field(
                        ichoice_code=indicator['ichoice_code'],
                        field_name=field_name,
                        field_display_name=field_display_name
                    )

                    if field_result > 0:
                        fields_count += 1

        logger.info(f"Populated database: {indicators_count} indicators, {fields_count} fields")
        return indicators_count, fields_count
