/* ============================================
   å·¥å…·å‡½æ•°
   ============================================ */

// ç”ŸæˆUUID
function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

// æ ¼å¼åŒ–æ—¥æœŸæ—¶é—´
function formatDateTime(timestamp) {
    if (!timestamp) return '-';
    const date = new Date(timestamp);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${year}-${month}-${day} ${hours}:${minutes}`;
}

// æ ¼å¼åŒ–æ—¥æœŸ
function formatDate(timestamp) {
    if (!timestamp) return '-';
    const date = new Date(timestamp);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// ç›¸å¯¹æ—¶é—´æ ¼å¼åŒ– (ä¾‹å¦‚: 5åˆ†é’Ÿå‰, 2å°æ—¶å‰)
function formatRelativeTime(timestamp) {
    if (!timestamp) return '-';
    const now = Date.now();
    const diff = now - timestamp;

    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    if (days > 7) {
        return formatDate(timestamp);
    } else if (days > 0) {
        return `${days}å¤©å‰`;
    } else if (hours > 0) {
        return `${hours}å°æ—¶å‰`;
    } else if (minutes > 0) {
        return `${minutes}åˆ†é’Ÿå‰`;
    } else {
        return 'åˆšåˆš';
    }
}

// æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
function formatFileSize(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}

// é˜²æŠ–å‡½æ•°
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// èŠ‚æµå‡½æ•°
function throttle(func, limit) {
    let inThrottle;
    return function(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// æ·±æ‹·è´å¯¹è±¡
function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (obj instanceof Date) return new Date(obj.getTime());
    if (obj instanceof Array) return obj.map(item => deepClone(item));
    if (obj instanceof Object) {
        const clonedObj = {};
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                clonedObj[key] = deepClone(obj[key]);
            }
        }
        return clonedObj;
    }
}

// æ–‡æœ¬é«˜äº®
function highlightText(text, query) {
    if (!query) return text;
    const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
}

// è½¬ä¹‰æ­£åˆ™è¡¨è¾¾å¼ç‰¹æ®Šå­—ç¬¦
function escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// ä¸‹è½½æ–‡ä»¶
function downloadFile(content, filename, mimeType) {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}

// è¯»å–æ–‡ä»¶ä¸ºBase64
function readFileAsBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
    });
}

// è¯»å–æ–‡ä»¶ä¸ºæ–‡æœ¬
function readFileAsText(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsText(file);
    });
}

// ä»Base64è·å–æ–‡ä»¶æ‰©å±•åå’ŒMIMEç±»å‹
function getMimeFromBase64(base64) {
    const match = base64.match(/^data:([^;]+);base64,/);
    return match ? match[1] : 'application/octet-stream';
}

// ä»æ–‡ä»¶åè·å–å›¾æ ‡emoji
function getFileIcon(filename) {
    const ext = filename.split('.').pop().toLowerCase();
    const iconMap = {
        'jpg': 'ğŸ–¼ï¸',
        'jpeg': 'ğŸ–¼ï¸',
        'png': 'ğŸ–¼ï¸',
        'gif': 'ğŸ–¼ï¸',
        'bmp': 'ğŸ–¼ï¸',
        'svg': 'ğŸ–¼ï¸',
        'pdf': 'ğŸ“„',
        'doc': 'ğŸ“',
        'docx': 'ğŸ“',
        'xls': 'ğŸ“Š',
        'xlsx': 'ğŸ“Š',
        'ppt': 'ğŸ“Š',
        'pptx': 'ğŸ“Š',
        'txt': 'ğŸ“ƒ',
        'zip': 'ğŸ“¦',
        'rar': 'ğŸ“¦',
        '7z': 'ğŸ“¦',
        'mp3': 'ğŸµ',
        'wav': 'ğŸµ',
        'mp4': 'ğŸ¬',
        'avi': 'ğŸ¬',
        'mov': 'ğŸ¬'
    };
    return iconMap[ext] || 'ğŸ“';
}

// ç»Ÿè®¡æ–‡æœ¬å­—æ•°
function countWords(text) {
    if (!text) return 0;
    // ç§»é™¤HTMLæ ‡ç­¾
    text = text.replace(/<[^>]*>/g, '');
    // ç§»é™¤ç©ºç™½å­—ç¬¦å¹¶è®¡æ•°
    text = text.trim();
    if (!text) return 0;

    // ä¸­æ–‡å­—ç¬¦ + è‹±æ–‡å•è¯
    const chineseChars = text.match(/[\u4e00-\u9fa5]/g) || [];
    const englishWords = text.match(/[a-zA-Z]+/g) || [];

    return chineseChars.length + englishWords.length;
}

// æ˜¾ç¤ºé€šçŸ¥æ¶ˆæ¯
function showNotification(message, type = 'info', duration = 3000) {
    // åˆ›å»ºé€šçŸ¥å…ƒç´ 
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.textContent = message;

    // æ·»åŠ æ ·å¼
    notification.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        padding: 12px 20px;
        background-color: ${type === 'success' ? '#4a7c59' : type === 'error' ? '#c94f4f' : '#2d5a7b'};
        color: white;
        border-radius: 6px;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        z-index: 10000;
        animation: slideIn 0.3s ease-out;
        font-size: 14px;
        max-width: 400px;
    `;

    document.body.appendChild(notification);

    // è‡ªåŠ¨ç§»é™¤
    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-out';
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, duration);
}

// æ·»åŠ é€šçŸ¥åŠ¨ç”»æ ·å¼
if (!document.getElementById('notification-styles')) {
    const style = document.createElement('style');
    style.id = 'notification-styles';
    style.textContent = `
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }
    `;
    document.head.appendChild(style);
}

// ç¡®è®¤å¯¹è¯æ¡†
function confirmDialog(message) {
    return confirm(message);
}

// æç¤ºå¯¹è¯æ¡†
function promptDialog(message, defaultValue = '') {
    return prompt(message, defaultValue);
}

// æœ¬åœ°å­˜å‚¨è¾…åŠ©å‡½æ•°
const LocalStorage = {
    set(key, value) {
        try {
            localStorage.setItem(key, JSON.stringify(value));
            return true;
        } catch (e) {
            console.error('LocalStorage.set error:', e);
            return false;
        }
    },

    get(key, defaultValue = null) {
        try {
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : defaultValue;
        } catch (e) {
            console.error('LocalStorage.get error:', e);
            return defaultValue;
        }
    },

    remove(key) {
        try {
            localStorage.removeItem(key);
            return true;
        } catch (e) {
            console.error('LocalStorage.remove error:', e);
            return false;
        }
    },

    clear() {
        try {
            localStorage.clear();
            return true;
        } catch (e) {
            console.error('LocalStorage.clear error:', e);
            return false;
        }
    }
};

// Quill Delta è½¬ Markdown
function deltaToMarkdown(delta) {
    if (!delta || !delta.ops) return '';

    let markdown = '';

    delta.ops.forEach(op => {
        if (typeof op.insert !== 'string') {
            if (op.insert.image) {
                markdown += `![image](${op.insert.image})\n`;
            }
            return;
        }

        let text = op.insert;

        if (op.attributes) {
            if (op.attributes.bold) text = `**${text}**`;
            if (op.attributes.italic) text = `*${text}*`;
            if (op.attributes.code) text = `\`${text}\``;
            if (op.attributes.strike) text = `~~${text}~~`;
            if (op.attributes.link) text = `[${text}](${op.attributes.link})`;

            if (op.attributes.header) {
                const level = op.attributes.header;
                text = '#'.repeat(level) + ' ' + text;
            }

            if (op.attributes.blockquote) {
                text = '> ' + text;
            }

            if (op.attributes.list) {
                if (op.attributes.list === 'ordered') {
                    text = '1. ' + text;
                } else if (op.attributes.list === 'bullet') {
                    text = '- ' + text;
                } else if (op.attributes.list === 'check') {
                    text = '- [ ] ' + text;
                }
            }
        }

        markdown += text;
    });

    return markdown;
}

// Quill Delta è½¬ HTML
function deltaToHtml(delta) {
    if (!delta || !delta.ops) return '';

    let html = '';

    delta.ops.forEach(op => {
        if (typeof op.insert !== 'string') {
            if (op.insert.image) {
                html += `<img src="${op.insert.image}" />`;
            }
            return;
        }

        let text = op.insert.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        text = text.replace(/\n/g, '<br>');

        if (op.attributes) {
            if (op.attributes.bold) text = `<strong>${text}</strong>`;
            if (op.attributes.italic) text = `<em>${text}</em>`;
            if (op.attributes.underline) text = `<u>${text}</u>`;
            if (op.attributes.strike) text = `<s>${text}</s>`;
            if (op.attributes.code) text = `<code>${text}</code>`;
            if (op.attributes.link) text = `<a href="${op.attributes.link}">${text}</a>`;

            if (op.attributes.header) {
                const level = op.attributes.header;
                text = `<h${level}>${text}</h${level}>`;
            }

            if (op.attributes.blockquote) {
                text = `<blockquote>${text}</blockquote>`;
            }

            if (op.attributes.list) {
                if (op.attributes.list === 'ordered') {
                    text = `<ol><li>${text}</li></ol>`;
                } else if (op.attributes.list === 'bullet') {
                    text = `<ul><li>${text}</li></ul>`;
                }
            }

            if (op.attributes.color) {
                text = `<span style="color: ${op.attributes.color}">${text}</span>`;
            }

            if (op.attributes.background) {
                text = `<span style="background-color: ${op.attributes.background}">${text}</span>`;
            }
        }

        html += text;
    });

    return html;
}
