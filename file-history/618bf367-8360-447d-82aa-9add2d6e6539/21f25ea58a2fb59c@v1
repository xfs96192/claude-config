/* ============================================
   IndexedDB æ•°æ®åº“æ“ä½œ
   ============================================ */

class Database {
    constructor() {
        this.dbName = 'InvestmentNotebook';
        this.version = 1;
        this.db = null;
    }

    // åˆå§‹åŒ–æ•°æ®åº“
    async init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.version);

            request.onerror = () => {
                console.error('Database failed to open:', request.error);
                reject(request.error);
            };

            request.onsuccess = () => {
                this.db = request.result;
                console.log('Database opened successfully');
                resolve(this.db);
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;

                // åˆ›å»º notebooks å¯¹è±¡å­˜å‚¨
                if (!db.objectStoreNames.contains('notebooks')) {
                    const notebookStore = db.createObjectStore('notebooks', { keyPath: 'id' });
                    notebookStore.createIndex('createdAt', 'createdAt', { unique: false });
                    notebookStore.createIndex('updatedAt', 'updatedAt', { unique: false });
                    notebookStore.createIndex('sortOrder', 'sortOrder', { unique: false });
                }

                // åˆ›å»º sections å¯¹è±¡å­˜å‚¨
                if (!db.objectStoreNames.contains('sections')) {
                    const sectionStore = db.createObjectStore('sections', { keyPath: 'id' });
                    sectionStore.createIndex('notebookId', 'notebookId', { unique: false });
                    sectionStore.createIndex('createdAt', 'createdAt', { unique: false });
                    sectionStore.createIndex('sortOrder', 'sortOrder', { unique: false });
                }

                // åˆ›å»º pages å¯¹è±¡å­˜å‚¨
                if (!db.objectStoreNames.contains('pages')) {
                    const pageStore = db.createObjectStore('pages', { keyPath: 'id' });
                    pageStore.createIndex('sectionId', 'sectionId', { unique: false });
                    pageStore.createIndex('type', 'type', { unique: false });
                    pageStore.createIndex('createdAt', 'createdAt', { unique: false });
                    pageStore.createIndex('updatedAt', 'updatedAt', { unique: false });
                    pageStore.createIndex('tags', 'tags', { unique: false, multiEntry: true });
                }

                // åˆ›å»º templates å¯¹è±¡å­˜å‚¨
                if (!db.objectStoreNames.contains('templates')) {
                    const templateStore = db.createObjectStore('templates', { keyPath: 'id' });
                    templateStore.createIndex('productType', 'productType', { unique: false });
                    templateStore.createIndex('createdAt', 'createdAt', { unique: false });
                }

                // åˆ›å»º attachments å¯¹è±¡å­˜å‚¨
                if (!db.objectStoreNames.contains('attachments')) {
                    const attachmentStore = db.createObjectStore('attachments', { keyPath: 'id' });
                    attachmentStore.createIndex('pageId', 'pageId', { unique: false });
                    attachmentStore.createIndex('createdAt', 'createdAt', { unique: false });
                }

                // åˆ›å»º todos å¯¹è±¡å­˜å‚¨
                if (!db.objectStoreNames.contains('todos')) {
                    const todoStore = db.createObjectStore('todos', { keyPath: 'id' });
                    todoStore.createIndex('pageId', 'pageId', { unique: false });
                    todoStore.createIndex('completed', 'completed', { unique: false });
                    todoStore.createIndex('dueDate', 'dueDate', { unique: false });
                    todoStore.createIndex('priority', 'priority', { unique: false });
                }

                console.log('Database setup complete');
            };
        });
    }

    // é€šç”¨æ·»åŠ æ–¹æ³•
    async add(storeName, data) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.add(data);

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    // é€šç”¨æ›´æ–°æ–¹æ³•
    async update(storeName, data) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.put(data);

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    // é€šç”¨è·å–æ–¹æ³•
    async get(storeName, id) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.get(id);

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    // é€šç”¨åˆ é™¤æ–¹æ³•
    async delete(storeName, id) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.delete(id);

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    // è·å–æ‰€æœ‰è®°å½•
    async getAll(storeName) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    // é€šè¿‡ç´¢å¼•è·å–
    async getByIndex(storeName, indexName, value) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const index = store.index(indexName);
            const request = index.getAll(value);

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    // ç¬”è®°æœ¬ç›¸å…³æ“ä½œ
    async createNotebook(name, type = 'general', icon = 'ğŸ“š', color = '#2d5a7b') {
        const notebook = {
            id: generateUUID(),
            name,
            type,
            icon,
            color,
            createdAt: Date.now(),
            updatedAt: Date.now(),
            sortOrder: await this.getNextSortOrder('notebooks')
        };
        await this.add('notebooks', notebook);
        return notebook;
    }

    async getNotebooks() {
        const notebooks = await this.getAll('notebooks');
        return notebooks.sort((a, b) => a.sortOrder - b.sortOrder);
    }

    async updateNotebook(id, updates) {
        const notebook = await this.get('notebooks', id);
        if (!notebook) throw new Error('Notebook not found');

        const updated = {
            ...notebook,
            ...updates,
            updatedAt: Date.now()
        };
        await this.update('notebooks', updated);
        return updated;
    }

    async deleteNotebook(id) {
        // åˆ é™¤ç¬”è®°æœ¬åŠå…¶æ‰€æœ‰åˆ†åŒºå’Œé¡µé¢
        const sections = await this.getByIndex('sections', 'notebookId', id);
        for (const section of sections) {
            await this.deleteSection(section.id);
        }
        await this.delete('notebooks', id);
    }

    // åˆ†åŒºç›¸å…³æ“ä½œ
    async createSection(notebookId, name, icon = 'ğŸ“') {
        const section = {
            id: generateUUID(),
            notebookId,
            name,
            icon,
            createdAt: Date.now(),
            updatedAt: Date.now(),
            sortOrder: await this.getNextSortOrder('sections', 'notebookId', notebookId)
        };
        await this.add('sections', section);
        return section;
    }

    async getSectionsByNotebook(notebookId) {
        const sections = await this.getByIndex('sections', 'notebookId', notebookId);
        return sections.sort((a, b) => a.sortOrder - b.sortOrder);
    }

    async updateSection(id, updates) {
        const section = await this.get('sections', id);
        if (!section) throw new Error('Section not found');

        const updated = {
            ...section,
            ...updates,
            updatedAt: Date.now()
        };
        await this.update('sections', updated);
        return updated;
    }

    async deleteSection(id) {
        // åˆ é™¤åˆ†åŒºåŠå…¶æ‰€æœ‰é¡µé¢
        const pages = await this.getByIndex('pages', 'sectionId', id);
        for (const page of pages) {
            await this.deletePage(page.id);
        }
        await this.delete('sections', id);
    }

    // é¡µé¢ç›¸å…³æ“ä½œ
    async createPage(sectionId, title = 'æ— æ ‡é¢˜é¡µé¢', type = 'note') {
        const page = {
            id: generateUUID(),
            sectionId,
            title,
            type,
            tags: [],
            content: { ops: [] }, // ç©ºçš„Quill Delta
            metadata: {},
            createdAt: Date.now(),
            updatedAt: Date.now(),
            isPinned: false,
            sortOrder: await this.getNextSortOrder('pages', 'sectionId', sectionId)
        };
        await this.add('pages', page);
        return page;
    }

    async getPagesBySection(sectionId) {
        const pages = await this.getByIndex('pages', 'sectionId', sectionId);
        return pages.sort((a, b) => {
            if (a.isPinned !== b.isPinned) return a.isPinned ? -1 : 1;
            return b.updatedAt - a.updatedAt;
        });
    }

    async updatePage(id, updates) {
        const page = await this.get('pages', id);
        if (!page) throw new Error('Page not found');

        const updated = {
            ...page,
            ...updates,
            updatedAt: Date.now()
        };
        await this.update('pages', updated);
        return updated;
    }

    async deletePage(id) {
        // åˆ é™¤é¡µé¢åŠå…¶é™„ä»¶å’Œå¾…åŠ
        const attachments = await this.getByIndex('attachments', 'pageId', id);
        for (const attachment of attachments) {
            await this.delete('attachments', attachment.id);
        }

        const todos = await this.getByIndex('todos', 'pageId', id);
        for (const todo of todos) {
            await this.delete('todos', todo.id);
        }

        await this.delete('pages', id);
    }

    async searchPages(query) {
        const allPages = await this.getAll('pages');
        const lowerQuery = query.toLowerCase();

        return allPages.filter(page => {
            // æœç´¢æ ‡é¢˜
            if (page.title.toLowerCase().includes(lowerQuery)) return true;

            // æœç´¢æ ‡ç­¾
            if (page.tags.some(tag => tag.toLowerCase().includes(lowerQuery))) return true;

            // æœç´¢å†…å®¹ (Deltaè½¬æ–‡æœ¬)
            if (page.content && page.content.ops) {
                const text = page.content.ops
                    .map(op => typeof op.insert === 'string' ? op.insert : '')
                    .join('')
                    .toLowerCase();
                if (text.includes(lowerQuery)) return true;
            }

            return false;
        });
    }

    // æ¨¡æ¿ç›¸å…³æ“ä½œ
    async createTemplate(name, productType, content, fields) {
        const template = {
            id: generateUUID(),
            name,
            productType,
            content,
            fields,
            createdAt: Date.now(),
            updatedAt: Date.now()
        };
        await this.add('templates', template);
        return template;
    }

    async getTemplates() {
        return await this.getAll('templates');
    }

    async getTemplatesByType(productType) {
        return await this.getByIndex('templates', 'productType', productType);
    }

    async deleteTemplate(id) {
        await this.delete('templates', id);
    }

    // é™„ä»¶ç›¸å…³æ“ä½œ
    async addAttachment(pageId, name, type, size, data) {
        const attachment = {
            id: generateUUID(),
            pageId,
            name,
            type,
            size,
            data,
            createdAt: Date.now()
        };
        await this.add('attachments', attachment);
        return attachment;
    }

    async getAttachmentsByPage(pageId) {
        return await this.getByIndex('attachments', 'pageId', pageId);
    }

    async deleteAttachment(id) {
        await this.delete('attachments', id);
    }

    // å¾…åŠç›¸å…³æ“ä½œ
    async createTodo(content, pageId = null, priority = 'medium', dueDate = null) {
        const todo = {
            id: generateUUID(),
            pageId,
            content,
            completed: false,
            priority,
            dueDate,
            tags: [],
            createdAt: Date.now(),
            updatedAt: Date.now()
        };
        await this.add('todos', todo);
        return todo;
    }

    async getTodos(pageId = null) {
        if (pageId) {
            return await this.getByIndex('todos', 'pageId', pageId);
        }
        return await this.getAll('todos');
    }

    async updateTodo(id, updates) {
        const todo = await this.get('todos', id);
        if (!todo) throw new Error('Todo not found');

        const updated = {
            ...todo,
            ...updates,
            updatedAt: Date.now()
        };
        await this.update('todos', updated);
        return updated;
    }

    async deleteTodo(id) {
        await this.delete('todos', id);
    }

    // è¾…åŠ©æ–¹æ³•ï¼šè·å–ä¸‹ä¸€ä¸ªæ’åºåºå·
    async getNextSortOrder(storeName, indexName = null, indexValue = null) {
        let items;
        if (indexName && indexValue) {
            items = await this.getByIndex(storeName, indexName, indexValue);
        } else {
            items = await this.getAll(storeName);
        }

        if (items.length === 0) return 0;

        const maxOrder = Math.max(...items.map(item => item.sortOrder || 0));
        return maxOrder + 1;
    }

    // å¯¼å‡ºæ‰€æœ‰æ•°æ®
    async exportAll() {
        const data = {
            notebooks: await this.getAll('notebooks'),
            sections: await this.getAll('sections'),
            pages: await this.getAll('pages'),
            templates: await this.getAll('templates'),
            attachments: await this.getAll('attachments'),
            todos: await this.getAll('todos'),
            exportedAt: Date.now()
        };
        return data;
    }

    // å¯¼å…¥æ•°æ®
    async importAll(data) {
        // æ¸…ç©ºç°æœ‰æ•°æ®
        const stores = ['notebooks', 'sections', 'pages', 'templates', 'attachments', 'todos'];
        for (const storeName of stores) {
            const items = await this.getAll(storeName);
            for (const item of items) {
                await this.delete(storeName, item.id);
            }
        }

        // å¯¼å…¥æ–°æ•°æ®
        for (const [storeName, items] of Object.entries(data)) {
            if (storeName === 'exportedAt') continue;
            if (!Array.isArray(items)) continue;

            for (const item of items) {
                await this.add(storeName, item);
            }
        }
    }

    // åˆå§‹åŒ–é»˜è®¤æ•°æ®
    async initializeDefaultData() {
        const notebooks = await this.getNotebooks();
        if (notebooks.length > 0) return; // å·²æœ‰æ•°æ®ï¼Œä¸åˆå§‹åŒ–

        // åˆ›å»ºé»˜è®¤ç¬”è®°æœ¬
        const notebook1 = await this.createNotebook('æƒç›Šç»„åˆ', 'product-group', 'ğŸ“Š', '#2d5a7b');
        const notebook2 = await this.createNotebook('å€ºåˆ¸ç»„åˆ', 'product-group', 'ğŸ“ˆ', '#4a7c59');
        const notebook3 = await this.createNotebook('ä¸ªäººç¬”è®°', 'general', 'ğŸ“', '#c97d60');

        // åˆ›å»ºé»˜è®¤åˆ†åŒº
        const section1 = await this.createSection(notebook1.id, '2024å¹´Q1', 'ğŸ“…');
        const section2 = await this.createSection(notebook2.id, 'åˆ©ç‡å€º', 'ğŸ’°');

        // åˆ›å»ºæ¬¢è¿é¡µé¢
        const welcomePage = await this.createPage(section1.id, 'æ¬¢è¿ä½¿ç”¨æŠ•èµ„ç»ç†è®°äº‹æœ¬', 'note');
        await this.updatePage(welcomePage.id, {
            content: {
                ops: [
                    { insert: 'æ¬¢è¿ä½¿ç”¨æŠ•èµ„ç»ç†è®°äº‹æœ¬\n', attributes: { header: 1 } },
                    { insert: '\nè¿™æ˜¯ä¸€ä¸ªä¸“ä¸ºæŠ•èµ„ç»ç†è®¾è®¡çš„è®°äº‹æœ¬åº”ç”¨ï¼Œæ”¯æŒï¼š\n\n' },
                    { insert: 'å¤šäº§å“ç®¡ç†', attributes: { list: 'bullet' } },
                    { insert: '\n' },
                    { insert: 'äº¤æ˜“æ—¥å¿—è®°å½•', attributes: { list: 'bullet' } },
                    { insert: '\n' },
                    { insert: 'å¾…åŠäº‹é¡¹', attributes: { list: 'bullet' } },
                    { insert: '\n' },
                    { insert: 'å¯Œæ–‡æœ¬ç¬”è®°', attributes: { list: 'bullet' } },
                    { insert: '\n\nå¼€å§‹ä½¿ç”¨å§ï¼\n' }
                ]
            },
            tags: ['æ¬¢è¿', 'æŒ‡å—']
        });

        // åˆ›å»ºé»˜è®¤æ¨¡æ¿
        await this.createTemplate(
            'è‚¡ç¥¨äº¤æ˜“æ—¥å¿—æ¨¡æ¿',
            'stock',
            {
                ops: [
                    { insert: 'äº¤æ˜“æ—¥å¿— - ', attributes: { header: 1 } },
                    { insert: '{productName}', attributes: { header: 1, bold: true } },
                    { insert: ' - {tradingDate}\n\n', attributes: { header: 1 } },
                    { insert: 'åŸºæœ¬ä¿¡æ¯\n', attributes: { header: 2 } },
                    { insert: 'å“ç§ä»£ç : {productCode}\n' },
                    { insert: 'äº¤æ˜“æ–¹å‘: {direction}\n' },
                    { insert: 'æˆäº¤ä»·æ ¼: {price}\n' },
                    { insert: 'æˆäº¤æ•°é‡: {quantity}\n\n' },
                    { insert: 'å¸‚åœºåˆ†æ\n', attributes: { header: 2 } },
                    { insert: '{analysis}\n\n' },
                    { insert: 'äº¤æ˜“é€»è¾‘\n', attributes: { header: 2 } },
                    { insert: '{logic}\n' }
                ]
            },
            [
                { name: 'tradingDate', label: 'äº¤æ˜“æ—¥æœŸ', type: 'date', required: true },
                { name: 'productName', label: 'äº§å“åç§°', type: 'text', required: true },
                { name: 'productCode', label: 'å“ç§ä»£ç ', type: 'text', required: true },
                {
                    name: 'direction',
                    label: 'äº¤æ˜“æ–¹å‘',
                    type: 'select',
                    options: ['ä¹°å…¥', 'å–å‡º'],
                    required: true
                },
                { name: 'price', label: 'æˆäº¤ä»·æ ¼', type: 'number', required: true },
                { name: 'quantity', label: 'æˆäº¤æ•°é‡', type: 'number', required: true },
                { name: 'analysis', label: 'å¸‚åœºåˆ†æ', type: 'richtext', required: false },
                { name: 'logic', label: 'äº¤æ˜“é€»è¾‘', type: 'richtext', required: false }
            ]
        );

        console.log('Default data initialized');
    }
}

// åˆ›å»ºå…¨å±€æ•°æ®åº“å®ä¾‹
const db = new Database();
